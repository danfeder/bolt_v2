This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.bolt/
  config.json
  prompt
data/
  Schedule_From_Json_Corrected.csv
memory-bank/
  implementationPhases/
    phase1_config.md
    phase2_metrics.md
    phase3_parallel.md
    phase4_experiment.md
  activeContext.md
  productContext.md
  progress.md
  projectbrief.md
  schedulerBuildPlan.md
  schedulingRequirements.md
  serverlessIntegration.md
  systemPatterns.md
  techContext.md
  testingPlanFullDataset.md
scheduler-backend/
  app/
    scheduling/
      constraints/
        __init__.py
        assignment.py
        base.py
        instructor.py
        limits.py
        periods.py
        teacher.py
      objectives/
        __init__.py
        base.py
        daily_balance.py
        day_usage.py
        distribution.py
        final_week.py
        required.py
      solvers/
        __init__.py
        base.py
        config.py
        dev.py
        stable.py
      utils/
        __init__.py
      __init__.py
      core.py
    utils/
      date_utils.py
    main.py
    models.py
    test_class_limits.py
  data/
    Schedule_From_Json_Corrected.csv
  tests/
    integration/
      test_scheduler.py
    performance/
      test_benchmarks.py
    unit/
      test_constraints.py
      test_distribution.py
    utils/
      assertions.py
      generators.py
    conftest.py
    README.md
  .gitignore
  Dockerfile
  pytest.ini
  README.md
  requirements.txt
src/
  components/
    Calendar.tsx
    ClassEditor.tsx
    ConstraintsForm.tsx
    FileUpload.tsx
    InstructorAvailability.tsx
    ScheduleComparison.tsx
    ScheduleDebugPanel.tsx
    SolverConfig.css
    SolverConfig.tsx
  lib/
    apiClient.ts
    csvParser.ts
    scheduleComplexity.ts
    scheduler.ts
    schedulerWorker.ts
  store/
    scheduleStore.ts
    testData.ts
    types.ts
  types/
    index.ts
  App.tsx
  index.css
  main.tsx
  vite-env.d.ts
.clinerules
.gitignore
eslint.config.js
index.html
package.json
postcss.config.js
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Files
================================================================

================
File: .bolt/config.json
================
{
  "template": "bolt-vite-react-ts"
}

================
File: .bolt/prompt
================
For all designs I ask you to make, have them be beautiful, not cookie cutter. Make webpages that are fully featured and worthy for production.

By default, this template supports JSX syntax with Tailwind CSS classes, React hooks, and Lucide React for icons. Do not install other packages for UI themes, icons, etc unless absolutely necessary or I request them.

Use icons from lucide-react for logos.

Use stock photos from unsplash where appropriate, only valid URLs you know exist. Do not download the images, only link to them in image tags.

================
File: data/Schedule_From_Json_Corrected.csv
================
Class,Monday,Tuesday,Wednesday,Thursday,Friday
PK207,2,2,4,3,"1, 3"
PK214,"2, 5","3, 5","1, 5","5, 7","2, 3, 5"
PK208,"2, 5","7, 5","2, 5","2, 5","3, 5, 7"
PK213,"2, 6","1, 6","6, 8","2, 6","3, 4, 6"
PK209,"4, 6","6, 6","2, 8","1, 6","2, 3, 6"
K-313,1,4,"2, 4",4,8
K-309,1,7,"2, 7",3,1
K-311,1,7,"2, 7",1,3
K-310,1,4,"2, 7",4,2
K-312,1,4,"2, 4",7,3
1-407,2,1,1,"2, 4",7
1-409,4,1,3,"2, 5",4
1-408,4,1,8,"2, 4",2
1-410,4,1,3,"2, 4",1
"K, 1, 2-417",7,1,4,"2, 4",2
2-411,7,"2, 8",1,8,2
2-414,7,"2, 4",1,1,4
2-412,7,"2, 4",1,7,6
2-413,7,"2, 7",1,4,6
3-418,8,3,"3, 8",1,8
3-420,4,7,"3, 8",1,2
3-416,"2, 8","5, 8","3, 7, 8",1,"3, 4"
3-419,8,5,"3, 8",1,5
3-415,8,2,"3, 7",1,7
4-509,1,8,3,"3, 8",1
4-508,2,6,7,"3, 6",1
4-510,6,7,1,"3, 6",1
4-515,6,1,6,"3, 7",1
"3, 4, 5-518",3,8,7,"3, 8",1
5-513,3,"3, 8",1,7,8
5-514,3,"3, 4",4,7,7
5-512,3,"3, 8",5,7,8
5-511,3,"3, 7",4,4,8

================
File: memory-bank/implementationPhases/phase1_config.md
================
# Phase 1: Configuration Management

## Implementation Steps

1. **File Structure Changes**
```python
scheduler-backend/app/scheduling/config/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ constraint_weights.py
â”œâ”€â”€ solver_params.py
â”œâ”€â”€ objective_priorities.py
â””â”€â”€ validation.py
```

2. **Weight Validation**
```python
class ConfigValidator:
    @classmethod
    def validate_weights(cls):
        """Ensure constraint weight hierarchy"""
        assert (
            ConstraintWeights.REQUIRED_PERIOD > 
            ConstraintWeights.EARLY_SCHEDULING
        ), "Required periods must have highest priority"
```

3. **Backwards Compatibility**
```python
# Legacy config.py
from .config import ConstraintWeights

REQUIRED_PERIOD_WEIGHT = ConstraintWeights.REQUIRED_PERIOD
# ... other legacy aliases
```

4. **Testing Strategy** 
- 100% test coverage for validation
- Legacy compatibility tests
- Weight hierarchy verification
- Solver integration tests
- Validate objective priority ordering matches runtime behavior

## Migration Timeline
```mermaid
gantt
    title Configuration Migration
    dateFormat  YYYY-MM-DD
    section Code Changes
    File Structure :done, 2025-02-15, 1d
    Validation :active, 2025-02-16, 2d
    Solver Integration :2025-02-18, 2d
    section Testing
    Unit Tests :2025-02-20, 2d
    Integration :2025-02-22, 1d

================
File: memory-bank/implementationPhases/phase2_metrics.md
================
# Phase 2: Metrics-Driven Optimization

## Core Components

1. **Quality Metrics Class**
```python
class QualityMetrics:
    def __init__(self, solution):
        self.solution = solution
        
    def calculate_balance(self):
        """Calculate distribution balance score (0-100)"""
        unique_counts = len(set(self.solution.teacher_assignments))
        total_classes = len(self.solution.class_schedule)
        return (unique_counts / total_classes) * 100

    def track_improvements(self):
        """Compare current vs historical metrics"""
        current = self.calculate_balance()
        historical = self.load_historical_average()
        return current - historical
```

2. **Dashboard Features**
- Real-time metric visualization using Plotly
- Parameter impact heatmaps
- Automated weight suggestion system
- Historical tracking of:
  - Objective coupling metrics
  - Weight adjustment impacts 
  - Cache effectiveness trends

## Implementation Steps
1. Create metrics service module
2. Integrate with solution callback system
3. Build React dashboard components
4. Implement historical data storage

## Validation Criteria
```mermaid
flowchart LR
    Test[Validation Tests] --> Accuracy
    Test --> Performance
    Test --> Reliability
    Accuracy --> A1[â‰¥90% metric accuracy]
    Performance --> P1[<1s dashboard updates]
    Reliability --> R1[30-day data retention]

================
File: memory-bank/implementationPhases/phase3_parallel.md
================
# Phase 3: Parallel Solving Architecture

## Worker Design
```mermaid
flowchart TD
    Main[Main Solver] --> Worker1[Worker Process]
    Main --> Worker2[Worker Process]
    Main --> Worker3[Worker Process]
    Worker1 --> Cache[(Solution Cache)]
    Worker2 --> Cache
    Worker3 --> Cache
```

## Key Components
1. **Worker Processes**
```python
class SolverWorker:
    def __init__(self, config):
        self.config = config
        self.cache = SolutionCache()
        
    def run(self, problem):
        """Solve problem with caching"""
        cached = self.cache.check(problem)
        if cached:
            return cached
        return self._solve(problem)
```

2. **Cache System**
- SHA-256 hash-based solution lookup
- LRU cache eviction policy
- Similarity scoring for partial matches

## Performance Targets
- 2x speedup on 4-core systems
- Linear scaling up to 16 cores
- 40% cache hit rate minimum

## Implementation Steps
1. Create worker pool management
2. Implement inter-process communication
3. Develop cache storage backend
4. Add resource monitoring

================
File: memory-bank/implementationPhases/phase4_experiment.md
================
# Phase 4: Experimentation Framework

## Parameter Search System
```mermaid
flowchart LR
    Space[Parameter Space] --> Generator
    Generator --> Workers[Experiment Workers]
    Workers --> Analyzer
    Analyzer --> Reports
```

## Version Control
```python
class ExperimentVersion:
    def __init__(self, params):
        self.params = params
        self.hash = self._generate_hash()
        
    def _generate_hash(self):
        """SHA-1 hash of parameter JSON"""
        return hashlib.sha1(
            json.dumps(self.params).encode()
        ).hexdigest()[:8]
```

## Implementation Steps
1. Create parameter space definition format
2. Build automated experiment runner
3. Implement versioned result storage
4. Develop analysis toolkit

## Validation Criteria
- 100% experiment reproducibility
- Automated regression detection
- Clear version migration paths
- Parameter impact scoring

================
File: memory-bank/activeContext.md
================
# Active Context: Gym Class Rotation Scheduler

## Current Status (February 2025)
We have completed a major code cleanup and reorganization:

### 1. Frontend Refactoring âœ…
- Removed legacy BacktrackingScheduler implementation
- Simplified frontend scheduler interface to use backend API
- Updated scheduler worker to handle async operations
- Streamlined complexity analysis for solver version selection
- Maintained all existing functionality with cleaner code

### 2. Backend Optimization âœ…
- Created shared solver configuration in `config.py`
- Consolidated common constraints and objectives
- Standardized priority weights across solvers
- Enhanced development solver flexibility
- Maintained solver performance and reliability

### 3. Development Workflow âœ…
Using standardized configuration between solvers:
- Base constraints and objectives in shared config
- Development version extends stable with experimental features
- Clear separation between stable and experimental code
- Easy comparison between solver versions
- Standardized weight hierarchy

### 4. Current Focus
1. Solution Quality
   - Testing alternative search strategies
   - Fine-tuning objective weights
   - Improving distribution balance
   - Enhancing early scheduling

2. Development Version
   - Experimenting with solver parameters
   - Testing new search heuristics
   - Validating quality improvements
   - Documenting successful patterns

## Priority System
Now centralized in `config.py`:
1. Required periods: 10000 (highest)
2. Early scheduling: 5000 (high)
3. Preferred periods: 1000 Ã— weight
4. Avoid periods: -500 Ã— weight
5. Distribution: 500
6. Earlier dates: 10 (lowest)

## Development Strategy
1. Solution Quality Focus
   - Test new search strategies
   - Balance objective weights
   - Analyze solution patterns
   - Compare with stable version

2. Implementation Approach
   - Incremental improvements in dev solver
   - A/B testing of changes
   - Quality metrics tracking
   - Clear documentation

3. Testing Strategy
   - Compare solution quality metrics
   - Validate improvements
   - Track solver performance
   - Document successful patterns

## Next Steps
1. Development Solver:
   - Implement new search strategies
   - Test objective weight adjustments
   - Try different solver parameters
   - Compare solution quality

2. Quality Metrics:
   - Define quality measures
   - Track improvements
   - Compare solutions
   - Validate changes

## Key Questions
1. Which search strategies yield best results?
2. How to better balance competing objectives?
3. What metrics best measure solution quality?
4. Which solver parameters most affect quality?

## Recent Achievements
1. Code Cleanup
   - Removed redundant frontend implementation
   - Consolidated solver configurations
   - Standardized priority weights
   - Enhanced development workflow

2. Architecture Improvements
   - Clear separation of concerns
   - Shared configuration management
   - Simplified frontend integration
   - Better type safety

3. Developer Experience
   - Cleaner codebase
   - Better documentation
   - Easier experimentation
   - Improved testing setup

## Code Organization
```
scheduler-backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ scheduling/
â”‚   â”‚   â”œâ”€â”€ constraints/      # Core constraints
â”‚   â”‚   â”œâ”€â”€ objectives/       # Scheduling objectives
â”‚   â”‚   â”œâ”€â”€ solvers/         # Solver implementations
â”‚   â”‚   â”‚   â”œâ”€â”€ config.py    # Shared configuration
â”‚   â”‚   â”‚   â”œâ”€â”€ stable.py    # Production solver
â”‚   â”‚   â”‚   â””â”€â”€ dev.py       # Experimental solver
â”‚   â”‚   â””â”€â”€ utils/           # Shared utilities
â”‚   â””â”€â”€ main.py              # API endpoints
```

## Current Constraints
All constraints now use shared configuration:
1. Single assignment per class
2. No overlapping classes
3. Teacher availability
4. Required periods
5. Conflict periods
6. Daily/weekly limits
7. Minimum periods per week

## Optimization Objectives
Standardized weights from config:
1. Required periods (highest)
2. Early scheduling
3. Preferred periods
4. Distribution balance
5. Avoided periods (penalties)
6. Earlier dates (lowest)

================
File: memory-bank/productContext.md
================
# Product Context: Gym Class Rotation Scheduler

## Current Development Phase
We are implementing the scheduler in a phased approach, focusing on one set of constraints at a time to ensure robustness and maintainability.

### Current Implementation (Phase 1 Complete)
- Basic scheduling engine using CP-SAT solver
- Core constraints: weekdays, valid periods, no overlaps
- Conflict period avoidance
- Basic schedule optimization

### Target Implementation (Phase 2 In Progress)
- Required periods assignment
- Teacher unavailability handling
- Comprehensive validation
- Detailed error reporting

## Core Functionality
The scheduler must handle:
1. Time Slot Validation
   - Weekday scheduling only
   - Valid periods (1-8)
   - No overlapping classes
   - Respect conflicts and requirements

2. Assignment Rules
   - Single assignment per class
   - Maximum classes per day/week
   - Minimum periods per week
   - Consecutive class rules

3. Teacher Availability
   - Unavailable period blocking
   - Teaching load limits

4. Period Preferences
   - Required periods (hard constraint)
   - Preferred periods (soft constraint)
   - Avoid periods (soft constraint)

5. Schedule Optimization
   - Minimize total duration
   - Even distribution
   - Preference satisfaction

## Testing Strategy
Each phase includes:
1. Unit tests for new constraints
2. Integration tests for constraint combinations
3. Performance testing with various dataset sizes
4. Validation and error reporting

## Success Metrics
- All hard constraints satisfied
- Soft constraints optimized where possible
- Clear error reporting
- Performance within acceptable limits
- Comprehensive test coverage

================
File: memory-bank/progress.md
================
# Progress Tracking: Scheduler Build Plan

## Development Infrastructure âœ…
### Completed Setup
- [x] Two-Version Development Workflow
  * Stable v2 version active
  * Development version created
  * Debug panel updated
  * API routes configured
- [x] Code Cleanup (February 2025)
  * Removed legacy frontend scheduler implementation
  * Consolidated solver configurations
  * Updated complexity analysis
  * Streamlined API integration

## Phase 1: Basic Scheduling âœ…
### Stable Features (v2)
- [x] Time Slot Validity
  * Classes only on weekdays
  * Valid periods (1-8)
  * No overlapping classes
- [x] Basic Assignment Rules
  * Each class scheduled exactly once
- [x] Basic Optimization
  * Minimize total schedule duration
  * Basic period distribution
- [x] Conflict Period Avoidance
  * Pre-filtered during variable creation
  * Validation and testing
  * Logging and error reporting

## Phase 2: Required Periods and Teacher Unavailability âœ…
### Development Version Progress
- [x] Required Periods Assignment
  * Model updates
  * Constraint implementation
  * Testing and validation
  * Error handling

### Completed
- [x] Teacher Unavailability
  * Data model updates
  * Constraint implementation
  * Integration testing
  * Validation checks

## Phase 3: Class Limit Constraints âœ…
### Completed & Promoted to Stable
- [x] Daily Limits
  * Maximum classes per day constraint
  * Daily tracking implementation
  * Validation and testing
  * Debug panel integration
- [x] Weekly Limits
  * Maximum classes per week constraint
  * Pro-rated first week minimums
  * Weekly tracking system
  * Validation checks
- [x] Consecutive Classes
  * Hard/soft constraint modes
  * Penalty system for soft constraints
  * Validation for hard constraints
  * Score adjustments for soft constraints
- [x] Promotion to Stable
  * Merged dev version into stable
  * Updated documentation
  * Verified with large dataset
  * Confirmed constraint satisfaction

## Phase 4: Period Preferences âœ…
### Completed & Verified
- [x] Preferred Periods
  * Added preference weighting system (1.0-2.5)
  * Integrated with objective function (1000 Ã— weight)
  * Implemented validation and reporting
  * Added preference satisfaction tracking
  * Verified with test data (3/5 preferred periods satisfied)
- [x] Avoid Periods
  * Added avoidance penalties (-500 Ã— weight)
  * Weighted penalties based on class settings (1.0-2.0)
  * Integrated with existing constraints
  * Added avoidance tracking
  * Verified with test data (0/5 avoid periods used)
- [x] Testing and Validation
  * Enhanced validation output with weights
  * Added preference satisfaction summary
  * Balanced with required periods (10000 points)
  * Maintained performance targets
  * Successfully tested with complex scenarios

## Phase 5: Advanced Optimization âœ…
### Completed & Promoted to Stable
- [x] Schedule Distribution
  * Even distribution across weeks (variance: 0.25)
  * Even distribution within weeks (period spread: 85%)
  * Distribution validation and metrics
  * Successfully balanced with existing constraints
- [x] Multi-Objective Balance
  * Implemented weighted penalties
  * Balanced distribution with preferences
  * Optimized teacher workload
  * Verified with test data

## Phase 6: Performance Optimization âœ…
### Completed & Verified
- [x] Search Space Reduction
  * Pre-filtered variable creation
  * Only create variables for valid periods
  * Removed redundant conflict constraints
  * Significant performance improvement
- [x] Partial Week Handling
  * Pro-rated first week minimums
  * Early scheduling in last week
  * Balanced full week distribution
  * Clear priority hierarchy
- [x] Priority System
  * Required periods (10000)
  * Early scheduling (5000)
  * Preferred periods (1000 Ã— weight)
  * Avoided periods (-500 Ã— weight)
  * Earlier dates (10 to 0)

## Phase 7: Solution Quality Improvements ðŸ”„
### In Development
- [ ] Search Strategy Optimization
  * Test alternative search heuristics
  * Experiment with solver parameters
  * Compare solution patterns
  * Document improvements
- [ ] Objective Weight Tuning
  * Fine-tune priority weights
  * Test different balances
  * Measure impact on quality
  * Validate improvements
- [ ] Distribution Enhancement
  * Improve period spread
  * Balance teacher workload
  * Optimize early scheduling
  * Track quality metrics

## Testing Infrastructure ðŸ”
### In Progress
- [ ] Quality Metrics
  * Solution pattern analysis
  * Distribution measurements
  * Preference satisfaction rates
  * Performance vs quality trade-offs
- [ ] Comparison Testing
  * A/B test solver changes
  * Compare with stable version
  * Document improvements
  * Validate quality gains

## Recent Code Cleanup (February 2025) âœ…
- [x] Frontend Cleanup
  * Removed legacy BacktrackingScheduler implementation
  * Simplified frontend scheduler interface
  * Updated worker to use async API calls
  * Streamlined complexity analysis
- [x] Backend Optimization
  * Created shared solver configuration
  * Consolidated constraint setup
  * Standardized priority weights
  * Enhanced development solver flexibility

## Known Issues ðŸ›
1. Need to identify best search strategies
2. Need to optimize objective weight balance
3. Need to improve distribution quality
4. Need to validate quality improvements

## Next Actions ðŸ“
1. Development Solver
   - Test new search heuristics
   - Adjust objective weights
   - Try solver parameters
   - Document improvements
2. Quality Metrics
   - Define quality measures
   - Track improvements
   - Compare solutions
   - Validate changes

## Change Log ðŸ“…
### February 10, 2025
- Completed major code cleanup and reorganization
- Removed legacy BacktrackingScheduler implementation
- Created shared solver configuration in config.py
- Standardized weight hierarchy across solvers
- Fixed import and initialization issues
- Verified functionality with frontend tests
- Updated all relevant documentation

================
File: memory-bank/projectbrief.md
================
# Project Brief: Gym Class Rotation Scheduler

## Overview
A sophisticated web application designed to automate the scheduling of gym classes in a school environment. The system creates optimal rotation schedules while respecting various constraints and preferences.

## Core Requirements

### Schedule Generation
- Generate conflict-free class schedules
- Support for multiple periods per day (1-8)
- Handle weekly recurring patterns
- Respect teacher availability
- Enforce maximum classes per day/week
- Handle consecutive class constraints

### Data Management
- Import class and availability data
- Edit class information
- Manage teacher availability
- Configure scheduling constraints

### User Interface
- Interactive calendar view
- Class editor interface
- Teacher availability management
- Constraint configuration
- Debug/testing capabilities

## Technical Goals
1. Maintain scheduling algorithm efficiency
2. Ensure responsive user interface
3. Provide clear error feedback
4. Support data import/export
5. Enable schedule visualization

## Success Criteria
- Generate valid schedules meeting all constraints
- Provide intuitive interface for data input
- Clear visualization of generated schedules
- Helpful error messages for constraint violations
- Support for testing and debugging

================
File: memory-bank/schedulerBuildPlan.md
================
# Scheduler Architecture Improvement Plan

## Phase Documentation Structure
```mermaid
flowchart TD
    Plan[schedulerBuildPlan.md] --> Phase1[phase1_config]
    Plan --> Phase2[phase2_metrics]
    Plan --> Phase3[phase3_parallel]
    Plan --> Phase4[phase4_experiment]
    
    Phase1 --> Config[Configuration Management]
    Phase2 --> Metrics[Quality Metrics]
    Phase3 --> Parallel[Parallel Solving]
    Phase4 --> Experiment[Experimentation]
    
    subgraph Implementation
        Config --> C1[Split Config]
        Config --> C2[Validation]
        Metrics --> M1[Dashboard]
        Metrics --> M2[Scoring]
        Parallel --> P1[Workers]
        Parallel --> P2[Cache]
        Experiment --> E1[Parameter Search]
        Experiment --> E2[Versioning]
    end
```

## Phase 1: Configuration Management
Document: [phase1_config.md](memory-bank/implementationPhases/phase1_config.md)
- Split monolithic config.py
- Create validation system covering:
  - Objective interaction checks
  - Weight boundary validation
  - Priority inversion prevention
- Dynamic weight adjustment API
- Backwards compatibility layer

## Phase 1 Addendum: Dynamic Configuration
```mermaid
flowchart LR
    API[Admin API] --> Weights[Weight Service]
    Weights --> Solver[Live Solver] 
    Solver --> Metrics
```

## Phase 2: Metrics-Driven Optimization  
Document: [phase2_metrics.md](memory-bank/implementationPhases/phase2_metrics.md)
- Quality metrics framework
- Automated scoring system
- Historical performance tracking
- Dashboard implementation

## Phase 3: Parallel Solving Architecture
Document: [phase3_parallel.md](memory-bank/implementationPhases/phase3_parallel.md)
- Worker process design
- Solution cache system
- Similarity scoring
- Resource management

## Phase 4: Experimentation Framework
Document: [phase4_experiment.md](memory-bank/implementationPhases/phase4_experiment.md)
- Parameter search implementation
- Version control system
- Automated experiment tracking
- Regression testing integration

## Timeline
```gantt
gantt
    title Scheduler Improvement Timeline
    dateFormat  YYYY-MM-DD
    section Documentation
    Phase 1 Docs     :done, des1, 2025-02-11, 1d
    Phase 2 Docs     :active, des2, 2025-02-12, 1d
    Phase 3 Docs     :         des3, 2025-02-13, 1d
    Phase 4 Docs     :         des4, 2025-02-14, 1d
    section Implementation
    Config Changes   :         crit, 2025-02-15, 3d
    Metrics System   :         crit, 2025-02-18, 5d
    Parallel Solver  :         crit, 2025-02-23, 5d
    Experimentation  :         crit, 2025-02-28, 7d
```

## Risk Management
```mermaid
flowchart LR
    Risk[Identified Risks] --> Mitigation
    Mitigation --> M1[Compatibility Layer]
    Mitigation --> M2[Performance Baselines]
    Mitigation --> M3[Automated Rollbacks]
    Mitigation --> M4[Extended Testing]
    Mitigation --> M5[Objective Decoupling]
```

## Testing Strategy
| Phase       | Test Type          | Tools               | Success Criteria          |
|-------------|--------------------|---------------------|---------------------------|
| Config      | Integration        | pytest, hypothesis  | 100% backwards compatibility |
| Metrics     | Validation         | pandas, numpy       | â‰¥90% metric accuracy      |
| Parallel    | Performance        | pytest-benchmark    | 2x speed improvement       |
| Experiment  | E2E                | Jupyter, matplotlib | Reproducible results      |

================
File: memory-bank/schedulingRequirements.md
================
# Scheduling Algorithm Requirements

## Hard Constraints
1. Time Slot Validity
   - Classes only on weekdays
   - Valid periods (1-8)
   - No scheduling during conflicts
   - Respect teacher unavailability
   - Required periods must be assigned

2. Assignment Rules
   - Each class scheduled exactly once
   - Maximum classes per day limit
   - Maximum classes per week limit
   - Minimum periods per week
   - Consecutive classes limit (when set as hard constraint)

3. Teacher Availability
   - No scheduling during teacher unavailable slots
   - Daily/weekly teaching load limits

## Soft Constraints
1. Period Preferences
   - Preferred periods
   - Avoid periods

2. Scheduling Preferences
   - Consecutive classes (when set as soft constraint)

## Optimization Objectives
1. Primary Goals
   - Satisfy all required period assignments (mandatory)
   - Maximize preferred period assignments
   - Minimize avoided period assignments

2. Secondary Goals
   - Minimize total schedule duration from start date
   - Balanced distribution within minimal duration:
     * Even distribution of classes across active weeks (within min/max bounds)
     * Even distribution of classes within each active week
   - Minimize consecutive classes (soft constraint)

## Performance Considerations
1. Caching Strategies
   - Valid time slot caching
   - Daily assignment count tracking
   - Weekly assignment count tracking
   - Date string caching

2. Optimization Techniques
   - Class ordering by constraint complexity
   - Randomized slot selection for better solutions
   - Progress tracking
   - Early constraint validation

## Validation Requirements
1. Schedule Verification
   - Daily limits check
   - Weekly limits check
   - Consecutive classes check
   - Complete schedule check
   - Single assignment per class

2. Error Handling
   - Clear error messages
   - Specific constraint violation feedback
   - Suggested resolution steps

================
File: memory-bank/serverlessIntegration.md
================
# Serverless Integration Plan

## Overview
Implementation plan for adding OR-Tools-based serverless scheduling functionality via Vercel, creating a hybrid approach that combines local and remote scheduling capabilities.

## Architecture
```mermaid
flowchart TD
    Client[Frontend Client]
    Store[Schedule Store]
    Local[Local Scheduler]
    API[Vercel API]
    OR[OR-Tools Solver]
    
    Client --> Store
    Store --> Decision{Schedule Size/Complexity}
    Decision -->|Simple| Local
    Decision -->|Complex| API
    API --> OR
    Local --> Store
    OR --> Store
```

## Implementation Phases

### Phase 1: Serverless Infrastructure Setup
1. Initialize Vercel Project
   - Configure project settings
   - Set up environment variables
   - Configure build settings

2. Create API Structure
```
api/
â”œâ”€â”€ schedule/
â”‚   â””â”€â”€ route.ts       # Main scheduling endpoint
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ or-tools.ts    # OR-Tools wrapper
â”‚   â”œâ”€â”€ scheduler.ts   # Core scheduling logic
â”‚   â””â”€â”€ types.ts       # Shared types
â””â”€â”€ package.json       # Backend dependencies
```

3. Set up OR-Tools
   - Install OR-Tools package
   - Create wrapper for constraint programming solver
   - Implement basic scheduling functionality

### Phase 2: Core Algorithm Implementation
1. Convert Constraints to OR-Tools Format
   - Map hard constraints to CP-SAT constraints
   - Implement objective functions for soft constraints
   - Set up optimization goals

2. Implement Scheduling Logic
   - Create variables for time slots
   - Define constraint satisfaction rules
   - Implement optimization objectives
   - Add solution validation

3. Create API Interface
   - Define request/response types
   - Implement error handling
   - Add input validation
   - Set up response streaming

### Phase 3: Frontend Integration
1. Create API Client
```typescript
interface ScheduleRequest {
  classes: Class[];
  teacherAvailability: TeacherAvailability[];
  constraints: ScheduleConstraints;
}

interface ScheduleResponse {
  assignments: ScheduleAssignment[];
  metadata: {
    solver: 'or-tools' | 'backtracking';
    duration: number;
    score: number;
  }
}
```

2. Modify Schedule Store
   - Add API integration
   - Implement hybrid scheduling strategy
   - Add loading states
   - Handle errors

3. Update UI Components
   - Add loading indicators
   - Enhance error displays
   - Show solver metadata
   - Add retry mechanisms

### Phase 4: Hybrid Strategy Implementation
1. Decision Logic
```typescript
const shouldUseServerless = (params: ScheduleParams): boolean => {
  return (
    params.classes.length > 10 ||           // Large dataset
    hasComplexConstraints(params) ||        // Complex constraints
    requiresAdvancedOptimization(params)    // Need better optimization
  );
};
```

2. Fallback Mechanism
   - Keep local scheduler as backup
   - Implement automatic fallback on failure
   - Add manual override option

3. Performance Optimization
   - Implement request caching
   - Add response streaming
   - Optimize data transfer

### Phase 5: Testing & Deployment
1. Testing Strategy
   - Unit tests for OR-Tools integration
   - API endpoint testing
   - Integration tests
   - Performance benchmarks

2. Deployment Process
   - Set up CI/CD pipeline
   - Configure monitoring
   - Add error tracking
   - Set up logging

3. Documentation
   - API documentation
   - Usage examples
   - Error handling guide
   - Performance considerations

## Success Criteria
1. Successful generation of schedules using OR-Tools
2. Improved optimization for complex schedules
3. Seamless fallback to local scheduler when appropriate
4. Performance improvements for large datasets
5. Comprehensive error handling and recovery

## Dependencies
1. Vercel account and configuration
2. OR-Tools package
3. TypeScript types sharing between frontend/backend
4. Testing infrastructure
5. Monitoring tools

## Risks and Mitigations
1. Risk: OR-Tools performance issues
   - Mitigation: Extensive testing with various dataset sizes
   - Fallback to local scheduler when needed

2. Risk: API reliability
   - Mitigation: Robust error handling
   - Automatic retry mechanisms
   - Local scheduler fallback

3. Risk: Data synchronization
   - Mitigation: Clear state management
   - Optimistic updates
   - Conflict resolution strategies

4. Risk: Development complexity
   - Mitigation: Phased approach
   - Comprehensive documentation
   - Clear separation of concerns

================
File: memory-bank/systemPatterns.md
================
# System Patterns: Gym Class Rotation Scheduler

## Architecture Overview

### Frontend Architecture
```mermaid
flowchart TD
    App --> Components
    App --> Store
    Store --> ApiClient
    
    subgraph Components
        Calendar
        ClassEditor
        TeacherAvailability
        ConstraintsForm
        FileUpload
        ScheduleDebugPanel
    end
    
    subgraph Store
        scheduleStore[Schedule Store]
    end
    
    subgraph ApiClient
        subgraph "Backend Solvers"
            StableV2[Stable v2]
            DevVersion[Development]
        end
    end
```

## Core Design Patterns

### 1. State Management
- **Pattern**: Centralized store using Zustand
- **Implementation**: `scheduleStore.ts`
- **Purpose**: Manage application state, schedule generation, and data persistence
- **Benefits**: Simplified state updates, predictable data flow

### 2. Development Workflow
- **Pattern**: Two-Version Development
- **Implementation**: 
  - Stable Version: `solvers/stable.py`
  - Development Version: `solvers/dev.py`
  - Shared Config: `solvers/config.py`
- **Key Features**:
  - Solution quality experimentation
  - Search strategy testing
  - Standardized configuration
  - Performance monitoring

### 3. Configuration Management
- **Pattern**: Centralized solver configuration
- **Implementation**: `solvers/config.py`
- **Key Features**:
  - Shared constraint definitions
  - Standard objective weights
  - Consistent priority hierarchy
  - Single source of truth for solver settings
- **Benefits**:
  - Simplified maintenance
  - Consistent behavior
  - Easy experimentation
  - Clear configuration documentation

### 4. Scheduling Algorithm
- **Pattern**: CP-SAT solver with optimized search
- **Implementation**: OR-Tools CP-SAT
- **Key Features**:
  - Pre-filtered variable creation
  - Search strategy optimization
  - Quality-focused objectives
  - Multi-objective balancing
  - Performance monitoring
  - Comprehensive validation

### 5. Component Architecture
- **Pattern**: Functional components with hooks
- **Structure**:
  ```
  scheduler-backend/
  â”œâ”€â”€ app/
  â”‚   â”œâ”€â”€ scheduling/
  â”‚   â”‚   â”œâ”€â”€ constraints/    # Scheduling constraints
  â”‚   â”‚   â”œâ”€â”€ objectives/     # Optimization objectives
  â”‚   â”‚   â”œâ”€â”€ solvers/       # Solver implementations
  â”‚   â”‚   â”‚   â”œâ”€â”€ config.py  # Shared configuration
  â”‚   â”‚   â”‚   â”œâ”€â”€ stable.py  # Stable solver
  â”‚   â”‚   â”‚   â””â”€â”€ dev.py     # Development solver
  â”‚   â”‚   â””â”€â”€ utils/         # Shared utilities
  â”‚   â””â”€â”€ models.py          # Data models
  ```

### 6. Data Models
- **Pattern**: TypeScript interfaces and Python dataclasses
- **Core Types**:
  - TimeSlot
  - WeeklySchedule
  - Class
  - TeacherAvailability
  - ScheduleAssignment
  - ScheduleConstraints
  - SchedulerContext

## Technical Decisions

### 1. Variable Creation Strategy
- **Pattern**: Pre-filtered variable creation
- **Implementation**:
  - Only create variables for valid periods
  - Filter out conflicting periods early
  - Reduce search space significantly
  - Track variable creation in debug info

### 2. Priority System (from config.py)
- **Pattern**: Hierarchical weights
- **Implementation**:
  1. Required periods (10000) - Highest priority
  2. Early scheduling (5000) - High priority
  3. Preferred periods (1000 Ã— weight) - Medium priority
  4. Avoided periods (-500 Ã— weight) - Penalty
  5. Distribution (500) - Balance schedule
  6. Earlier dates (10) - Slight preference

### 3. Search Strategy
- **Pattern**: Quality-focused search
- **Implementation**:
  - Alternative search heuristics
  - Solver parameter tuning
  - Solution pattern analysis
  - Quality metrics tracking

### 4. Data Sharing
- **Pattern**: Context-based communication
- **Implementation**:
  - SchedulerContext for shared state
  - debug_info for cross-component data
  - Quality metrics tracking
  - Enhanced logging capabilities

## Performance Patterns

### 1. Search Space Optimization
- Pre-filtered variable creation
- Quality-focused search strategies
- Solution pattern analysis
- Efficient constraint application

### 2. Development Strategies
- Solution quality experiments
- A/B testing changes
- Quality metrics tracking
- Pattern documentation

## Error Handling
- Detailed variable creation logs
- Constraint validation feedback
- Quality metric monitoring
- Performance tracking metrics

## Testing Strategy
- Solution quality verification
- Search strategy validation
- Quality metrics tracking
- Performance benchmarking

================
File: memory-bank/techContext.md
================
# Technical Context: Gym Class Rotation Scheduler

## Development Environment

### Core Technologies
- **Frontend**:
  - **Node.js**: Runtime environment
  - **TypeScript**: Programming language
  - **React**: UI framework
  - **Vite**: Build tool and dev server
- **Backend**:
  - **Python 3.11**: Runtime environment (required for OR-Tools)
  - **FastAPI**: Web framework
  - **OR-Tools**: Constraint programming solver
  - **Pydantic**: Data validation

### Key Dependencies
```json
{
  "Frontend Framework": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "State Management": {
    "zustand": "^4.5.2"
  },
  "UI Components": {
    "@tanstack/react-table": "^8.13.2",
    "lucide-react": "^0.344.0"
  },
  "Date Handling": {
    "date-fns": "^3.3.1"
  },
  "Scheduling": {
    "logic-solver": "^2.0.1"
  },
  "Styling": {
    "tailwindcss": "^3.4.1",
    "postcss": "^8.4.35",
    "autoprefixer": "^10.4.18"
  }
}
```

## Project Structure
```
/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/        # React components
â”‚   â”‚   â”œâ”€â”€ Calendar.tsx
â”‚   â”‚   â”œâ”€â”€ ClassEditor.tsx
â”‚   â”‚   â”œâ”€â”€ ConstraintsForm.tsx
â”‚   â”‚   â”œâ”€â”€ FileUpload.tsx
â”‚   â”‚   â”œâ”€â”€ ScheduleDebugPanel.tsx
â”‚   â”‚   â””â”€â”€ TeacherAvailability.tsx
â”‚   â”œâ”€â”€ lib/              # Core business logic
â”‚   â”‚   â”œâ”€â”€ csvParser.ts
â”‚   â”‚   â”œâ”€â”€ scheduler.ts
â”‚   â”‚   â””â”€â”€ schedulerWorker.ts
â”‚   â”œâ”€â”€ store/            # State management
â”‚   â”‚   â”œâ”€â”€ scheduleStore.ts
â”‚   â”‚   â””â”€â”€ testData.ts
â”‚   â”œâ”€â”€ types/            # TypeScript definitions
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ App.tsx           # Root component
â”‚   â”œâ”€â”€ index.css         # Global styles
â”‚   â””â”€â”€ main.tsx          # Entry point
â”œâ”€â”€ public/               # Static assets
â”œâ”€â”€ package.json          # Dependencies
â”œâ”€â”€ tsconfig.json         # TypeScript config
â”œâ”€â”€ vite.config.ts        # Vite config
â””â”€â”€ tailwind.config.js    # Tailwind config
```

## Development Setup

### Prerequisites
- **Frontend**:
  - Node.js (LTS version)
  - npm/yarn package manager
  - Modern web browser
  - Code editor with TypeScript support
- **Backend**:
  - Python 3.11 (required for OR-Tools compatibility)
  - Homebrew (recommended for Python installation)
  - Virtual environment for Python dependencies

### Build Scripts
#### Frontend
```json
{
  "dev": "vite",              // Development server
  "build": "vite build",      // Production build
  "lint": "eslint .",         // Code linting
  "preview": "vite preview"   // Preview build
}
```

#### Backend
```bash
# Create virtual environment
/opt/homebrew/bin/python3.11 -m venv venv

# Activate virtual environment
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Run development server
uvicorn app.main:app --reload

# Run tests
python -m app.test_class_limits
```

## Technical Constraints

### Browser Support
- Modern browsers with ES6+ support
- No IE11 support required
- CSS Grid and Flexbox support required

### Performance Requirements
- Fast schedule generation (<5s for typical scenarios)
- Responsive UI updates
- Efficient state management
- Optimized re-renders

### Data Handling
- CSV import support
- JSON data structures
- Local state persistence
- Type-safe data management

## Development Patterns

### Code Style
- Functional React components
- TypeScript strict mode
- ESLint for code quality
- Tailwind for styling

### State Management
- Zustand store
- Immutable state updates
- TypeScript type safety
- Centralized store pattern

### Testing Strategy
- Component testing
- Algorithm validation
- Constraint verification
- Debug panel for monitoring

### Build Process
- Vite development server
- TypeScript compilation
- PostCSS processing
- Tailwind CSS compilation

================
File: memory-bank/testingPlanFullDataset.md
================
# Testing Plan: Full Dataset Approach

This testing plan uses the full dataset provided in `data/Schedule_From_Json_Corrected.csv` for all test cases. The goal is to validate our scheduler's functionality by applying every constraint on the actual data, rather than using artificially small datasets.

## Overview
- **Data Source:** `data/Schedule_From_Json_Corrected.csv`
- **Number of Classes:** 33 (as loaded from the CSV)
- **Key Constraints to Validate:**
  - **Time Slot Validity:** 
    - Classes are only scheduled on weekdays (Mon-Fri) and in valid periods (1-8).
  - **Conflict Period Avoidance:** 
    - No class is scheduled during any conflict period provided in the CSV.
  - **Assignment Rules:** 
    - Each class is scheduled exactly once.
    - No overlapping classes occur in the same day/period.
  - **Optimization Objective:** 
    - The schedule minimizes the total duration by preferring early dates and lower periods.
  - **(Upcoming in Phase 2) Required Periods & Teacher Unavailability:**
    - While these are not yet implemented, the plan is to extend tests later using the full dataset.

## Testing Steps

### 1. Schedule Generation
- Run the complete scheduler (phase 1 implementation) with the full CSV dataset.
- Verify that:
  - The CSV is correctly parsed and all 33 classes are loaded.
  - The scheduler generates a schedule with exactly 33 assignments.
  - The server logs print detailed conflict constraints, objective details, and a schedule summary.

### 2. Validation of Hard Constraints
- **Time Slot Validity:**
  - Confirm that all assignments are on weekdays and within period 1-8.
- **Assignment Rules:**
  - Verify each class is assigned exactly once.
  - Check the schedule summary to ensure there are no overlapping assignments within the same day/period.
- **Conflict Periods:**
  - Validate using the detailed â€œClass Conflicts Summaryâ€ output that none of the assignments falls on a conflict period specified for their class.
  
### 3. Inspection of Optimization Objective
- Examine the generated schedule and the computed score.
  - The objective should favor earlier dates and lower periods.
  - The solver logs should indicate that the objective function was added.
  
### 4. Full Schedule Analysis
- Use the Debug Panelâ€™s â€œDownload Schedule Dataâ€ functionality to export the complete schedule.
- Manually (or with automated scripts) compare:
  - Each classâ€™s scheduled time slot against its conflict list.
  - The distribution of classes across days.
  
### 5. Automated Script Option (Optional)
- Develop a simple script to:
  - Load the full CSV using the existing CSV parser.
  - Run the scheduler automatically.
  - Compare each assignment with the corresponding classâ€™s conflict periods.
  - Report any violations or anomalies.
  
## Expected Results
- **Conflict Constraints:** All conflict constraints (as per CSV) are respected, with logging output confirming the number of conflict constraints added (e.g., "Added 888 conflict constraints").
- **Assignment Completeness:** The schedule has 33 assignments with no double-booking and without any assignment falling into a conflict period.
- **Distribution:** Classes are spread over the earliest available dates (as per the optimization objective), favoring early periods.
- **Performance:** The scheduler completes within reasonable time, and the full dataset is handled without memory/performance issues.

## Success Criteria
- All hard constraints (time slot validity, single assignment, conflict avoidance) pass validation.
- The objective function is effective in placing assignments early.
- Detailed validation output (printed in the terminal) confirms that no violations occur.
- The full dataset is used for testing, ensuring real-world conditions.

---

This plan ensures that our tests are comprehensive by using the entire dataset, giving us confidence that our scheduler behaves correctly under real conditions.

================
File: scheduler-backend/app/scheduling/constraints/__init__.py
================
from .base import BaseConstraint, ConstraintViolation
from .assignment import SingleAssignmentConstraint, NoOverlapConstraint
from .instructor import InstructorAvailabilityConstraint
from .periods import RequiredPeriodsConstraint, ConflictPeriodsConstraint

__all__ = [
    'BaseConstraint',
    'ConstraintViolation',
    'SingleAssignmentConstraint',
    'NoOverlapConstraint',
    'InstructorAvailabilityConstraint',
    'RequiredPeriodsConstraint',
    'ConflictPeriodsConstraint'
]

================
File: scheduler-backend/app/scheduling/constraints/assignment.py
================
from collections import defaultdict
from typing import List, Dict, Any

from ortools.sat.python import cp_model

from .base import BaseConstraint, ConstraintViolation
from ..core import SchedulerContext

class SingleAssignmentConstraint(BaseConstraint):
    """Ensures each class is scheduled exactly once"""
    
    def __init__(self):
        super().__init__("single_assignment")
    
    def apply(self, context: SchedulerContext) -> None:
        # Group variables by class
        by_class = defaultdict(list)
        for var in context.variables:
            by_class[var["name"]].append(var["variable"])
        
        # Add constraint for each class
        for class_name, vars_list in by_class.items():
            context.model.Add(sum(vars_list) == 1)
            
        print(f"Added single assignment constraints for {len(by_class)} classes")
    
    def validate(
        self,
        assignments: List[Dict[str, Any]],
        context: SchedulerContext
    ) -> List[ConstraintViolation]:
        violations = []
        
        # Count assignments per class using property access
        assignments_per_class = defaultdict(int)
        for assignment in assignments:
            assignments_per_class[assignment.name] += 1
        
        # Check for missing or duplicate assignments
        for class_obj in context.request.classes:
            count = assignments_per_class[class_obj.name]
            if count == 0:
                violations.append(ConstraintViolation(
                    message=f"Class {class_obj.name} is not scheduled",
                    severity="error",
                    context={"name": class_obj.name}
                ))
            elif count > 1:
                violations.append(ConstraintViolation(
                    message=f"Class {class_obj.name} is scheduled {count} times",
                    severity="error",
                    context={
                        "name": class_obj.name,
                        "assignmentCount": count
                    }
                ))
        
        return violations

class NoOverlapConstraint(BaseConstraint):
    """Ensures no two classes are scheduled in the same period"""
    
    def __init__(self):
        super().__init__("no_overlap")
    
    def apply(self, context: SchedulerContext) -> None:
        # Group variables by date and period
        by_slot = defaultdict(list)
        for var in context.variables:
            key = (var["date"].date(), var["period"])
            by_slot[key].append(var["variable"])
        
        # Add constraint for each time slot
        overlap_constraints = 0
        for key, vars_list in by_slot.items():
            if len(vars_list) > 1:  # Only need constraint if multiple classes could be scheduled
                context.model.Add(sum(vars_list) <= 1)
                overlap_constraints += 1
                
        print(f"Added {overlap_constraints} no-overlap constraints")
    
    def validate(
        self,
        assignments: List[Dict[str, Any]],
        context: SchedulerContext
    ) -> List[ConstraintViolation]:
        violations = []
        
        # Group assignments by time slot
        by_slot = defaultdict(list)
        for assignment in assignments:
            key = (assignment.date, assignment.timeSlot.period)
            by_slot[key].append(assignment)
        
        # Check for overlaps
        for (date, period), slot_assignments in by_slot.items():
            if len(slot_assignments) > 1:
                class_names = [a.name for a in slot_assignments]
                violations.append(ConstraintViolation(
                    message=f"Multiple classes scheduled for {date} period {period}",
                    severity="error",
                    context={
                        "date": date,
                        "period": period,
                        "names": class_names
                    }
                ))
        
        return violations

================
File: scheduler-backend/app/scheduling/constraints/base.py
================
from dataclasses import dataclass
from typing import List, Dict, Any, Optional
from datetime import datetime

from ortools.sat.python import cp_model

from ..core import Constraint, SchedulerContext

@dataclass
class ConstraintViolation:
    """Represents a constraint violation for validation"""
    message: str
    severity: str  # 'error' or 'warning'
    context: Dict[str, Any]

class BaseConstraint:
    """Base class for implementing constraints"""
    def __init__(self, name: str):
        self._name = name
        
    @property
    def name(self) -> str:
        return self._name
    
    def validate(
        self,
        assignments: List[Dict[str, Any]],
        context: SchedulerContext
    ) -> List[ConstraintViolation]:
        """
        Validate that assignments satisfy this constraint.
        Returns list of violations found.
        """
        return []

================
File: scheduler-backend/app/scheduling/constraints/instructor.py
================
from collections import defaultdict
from typing import List, Dict, Any, Set, Tuple
from datetime import datetime
from dateutil.tz import UTC

from ortools.sat.python import cp_model

from .base import BaseConstraint, ConstraintViolation
from ..core import SchedulerContext

class InstructorAvailabilityConstraint(BaseConstraint):
    """Ensures classes are only scheduled when instructor is available"""
    
    def __init__(self):
        super().__init__("instructor_availability")
        
    def apply(self, context: SchedulerContext) -> None:
        # Build lookup of unavailable periods
        unavailable_slots: Dict[str, Set[int]] = defaultdict(set)
        for avail in context.request.instructorAvailability:
            avail_date = datetime.fromisoformat(avail.date)
            if avail_date.tzinfo is None:
                avail_date = avail_date.replace(tzinfo=UTC)
            date_str = avail_date.date().isoformat()
            unavailable_slots[date_str].update(avail.periods)
        
        # Add constraints for each variable that would be during an unavailable period
        unavailable_count = 0
        for var in context.variables:
            date_str = var["date"].date().isoformat()
            if date_str in unavailable_slots and var["period"] in unavailable_slots[date_str]:
                context.model.Add(var["variable"] == 0)
                unavailable_count += 1
        
        print(f"Added {unavailable_count} instructor availability constraints")
    
    def validate(
        self,
        assignments: List[Dict[str, Any]],
        context: SchedulerContext
    ) -> List[ConstraintViolation]:
        violations = []
        
        # Build lookup of unavailable periods
        unavailable_slots: Dict[str, Set[int]] = defaultdict(set)
        for avail in context.request.instructorAvailability:
            avail_date = datetime.fromisoformat(avail.date)
            if avail_date.tzinfo is None:
                avail_date = avail_date.replace(tzinfo=UTC)
            date_str = avail_date.date().isoformat()
            unavailable_slots[date_str].update(avail.periods)
        
        # Check each assignment
        for assignment in assignments:
            date = datetime.fromisoformat(assignment.date).date().isoformat()
            period = assignment.timeSlot.period
            if date in unavailable_slots and period in unavailable_slots[date]:
                violations.append(ConstraintViolation(
                    message=(
                        f"Class {assignment.name} scheduled during "
                        f"unavailable period {period} on {date}"
                    ),
                    severity="error",
                    context={
                        "name": assignment.name,
                        "date": date,
                        "period": period
                    }
                ))
        return violations

class ConsecutivePeriodConstraint(BaseConstraint):
    """Prevents an instructor from being scheduled for consecutive periods in a day."""
    
    def __init__(self):
        super().__init__("consecutive_period")
        
    def apply(self, context: SchedulerContext) -> None:
        from collections import defaultdict
        instructor_daily = defaultdict(list)
        # Group variables by instructor and day, with their period and variable indicator.
        for var in context.variables:
            instructor = var.get("instructor")
            if instructor:
                day = var["date"].date()
                instructor_daily[(instructor, day)].append((var["period"], var["variable"]))
        # For each group, sort by period and add consecutive constraints.
        for key, period_vars in instructor_daily.items():
            period_vars.sort(key=lambda x: x[0])
            for i in range(len(period_vars) - 1):
                context.model.Add(period_vars[i][1] + period_vars[i+1][1] <= 1)
        print("Added consecutive period constraints for instructors")
        
    def validate(self, assignments: List[Dict[str, Any]], context: SchedulerContext) -> List[ConstraintViolation]:
        # Validation logic can be implemented if needed.
        return []

================
File: scheduler-backend/app/scheduling/constraints/limits.py
================
from collections import defaultdict
from datetime import datetime
from typing import List, Dict, Any

from ortools.sat.python import cp_model

from .base import BaseConstraint, ConstraintViolation
from ..core import SchedulerContext

class DailyLimitConstraint(BaseConstraint):
    """Ensures the number of classes per day doesn't exceed the maximum"""
    
    def __init__(self):
        super().__init__("daily_limit")
    
    def apply(self, context: SchedulerContext) -> None:
        # Group variables by date
        by_date = defaultdict(list)
        for var in context.variables:
            # var["date"] is already a datetime object from base solver
            date = var["date"].date()
            by_date[date].append(var["variable"])
        
        # Add constraint for each date
        limit_count = 0
        for date, vars_list in by_date.items():
            print(f"Adding daily limit constraint for {date}: {len(vars_list)} variables")
            context.model.Add(
                sum(vars_list) <= context.request.constraints.maxClassesPerDay
            )
            limit_count += 1
            
        print(f"Added daily limit constraints for {limit_count} days")
    
    def validate(
        self,
        assignments: List[Dict[str, Any]],
        context: SchedulerContext
    ) -> List[ConstraintViolation]:
        violations = []
        
        # Count assignments per day
        by_date = defaultdict(int)
        for assignment in assignments:
            date = datetime.fromisoformat(assignment.date).date()
            by_date[date] += 1
        
        # Check for violations
        for date, count in by_date.items():
            if count > context.request.constraints.maxClassesPerDay:
                violations.append(ConstraintViolation(
                    message=(
                        f"Too many classes scheduled on {date}: "
                        f"got {count}, maximum is {context.request.constraints.maxClassesPerDay}"
                    ),
                    severity="error",
                    context={
                        "date": str(date),
                        "count": count,
                        "maximum": context.request.constraints.maxClassesPerDay
                    }
                ))
        
        return violations

class WeeklyLimitConstraint(BaseConstraint):
    """Ensures the number of classes per week doesn't exceed the maximum"""
    
    def __init__(self):
        super().__init__("weekly_limit")
    
    def apply(self, context: SchedulerContext) -> None:
        # Group variables by week
        by_week = defaultdict(list)
        for var in context.variables:
            # Both var["date"] and context.start_date are datetime objects
            week_num = (var["date"] - context.start_date).days // 7
            by_week[week_num].append(var["variable"])
            
        # Add constraint for each week
        limit_count = 0
        for week_num, vars_list in by_week.items():
            print(f"Adding weekly limit constraint for week {week_num}: {len(vars_list)} variables")
            context.model.Add(
                sum(vars_list) <= context.request.constraints.maxClassesPerWeek
            )
            limit_count += 1
            
        print(f"Added weekly limit constraints for {limit_count} weeks")
    
    def validate(
        self,
        assignments: List[Dict[str, Any]],
        context: SchedulerContext
    ) -> List[ConstraintViolation]:
        violations = []
        
        # Count assignments per week
        by_week = defaultdict(int)
        for assignment in assignments:
            date = datetime.fromisoformat(assignment.date)
            week_num = (date - context.start_date).days // 7
            by_week[week_num] += 1
        
        # Check for violations
        for week_num, count in by_week.items():
            if count > context.request.constraints.maxClassesPerWeek:
                violations.append(ConstraintViolation(
                    message=(
                        f"Too many classes scheduled in week {week_num + 1}: "
                        f"got {count}, maximum is {context.request.constraints.maxClassesPerWeek}"
                    ),
                    severity="error",
                    context={
                        "weekNumber": week_num + 1,
                        "count": count,
                        "maximum": context.request.constraints.maxClassesPerWeek
                    }
                ))
        
        return violations

class MinimumPeriodsConstraint(BaseConstraint):
    """Ensures the minimum number of classes per week is met"""
    
    def __init__(self):
        super().__init__("minimum_periods")
    
    def apply(self, context: SchedulerContext) -> None:
        # Group variables by week and count weekdays per week
        by_week = defaultdict(list)
        by_day = defaultdict(lambda: defaultdict(list))  # week -> day -> vars
        weekdays_by_week = defaultdict(int)
        seen_dates = set()  # Track unique dates to avoid double-counting
        
        for var in context.variables:
            week_num = (var["date"] - context.start_date).days // 7
            date = var["date"].date()
            
            # Count weekdays (only once per date)
            if date not in seen_dates and var["date"].weekday() < 5:
                weekdays_by_week[week_num] += 1
                seen_dates.add(date)
            
            by_week[week_num].append(var["variable"])
            by_day[week_num][date].append(var)
        
        # Add constraint for each week
        limit_count = 0
        sorted_weeks = sorted(by_week.keys())
        first_week = sorted_weeks[0] if sorted_weeks else 0
        last_week = sorted_weeks[-1] if sorted_weeks else 0
        
        # Calculate total remaining classes to schedule
        total_classes = len(context.request.classes)
        
        for week_num, vars_list in by_week.items():
            weekdays = weekdays_by_week[week_num]
            
            if week_num == first_week:
                # Pro-rate minimum for first week based on available weekdays
                min_periods = (context.request.constraints.minPeriodsPerWeek * weekdays) // 5
                print(f"Adding pro-rated minimum periods constraint for first week {week_num}:")
                print(f"- {len(vars_list)} variables")
                print(f"- {weekdays} weekdays")
                print(f"- Minimum periods: {min_periods}")
                context.model.Add(sum(vars_list) >= min_periods)
                limit_count += 1
                
            elif week_num == last_week:
                # For last week, encourage scheduling early in the week
                # Sort days in ascending order
                sorted_days = sorted(by_day[week_num].keys())
                cumulative_vars = []
                
                # Add variables day by day
                for day in sorted_days:
                    day_vars = [v["variable"] for v in by_day[week_num][day]]
                    cumulative_vars.extend(day_vars)
                    
                    # Try to schedule any remaining classes in these slots
                    remaining = total_classes - sum(len(by_day[w][d]) for w in sorted_weeks 
                                                 for d in by_day[w].keys() if w < week_num or 
                                                 (w == week_num and d < day))
                    if remaining > 0:
                        print(f"Encouraging scheduling {remaining} remaining classes on {day}")
                        # Add soft constraint with high weight to encourage early scheduling
                        early_var = context.model.NewIntVar(0, remaining, f"early_scheduling_{day}")
                        context.model.Add(early_var <= sum(day_vars))
                        
                        # Store early scheduling variables in context
                        if "early_scheduling_vars" not in context.debug_info:
                            context.debug_info["early_scheduling_vars"] = []
                        context.debug_info["early_scheduling_vars"].append(early_var)
                
            else:
                # Normal week - use full minimum
                print(f"Adding minimum periods constraint for week {week_num}:")
                print(f"- {len(vars_list)} variables")
                print(f"- {weekdays} weekdays")
                print(f"- Minimum periods: {context.request.constraints.minPeriodsPerWeek}")
                context.model.Add(sum(vars_list) >= context.request.constraints.minPeriodsPerWeek)
                limit_count += 1
            
        print(f"Added minimum periods constraints for {limit_count} weeks")
    
    def validate(
        self,
        assignments: List[Dict[str, Any]],
        context: SchedulerContext
    ) -> List[ConstraintViolation]:
        violations = []
        
        # Count assignments per week and also track weekdays per week
        by_week = defaultdict(int)
        weekdays_by_week = defaultdict(set)  # Use set to count unique weekdays
        
        for assignment in assignments:
            date = datetime.fromisoformat(assignment.date)
            week_num = (date - context.start_date).days // 7
            by_week[week_num] += 1
            
            # Only track weekdays (Mon-Fri)
            if date.weekday() < 5:
                weekdays_by_week[week_num].add(date.date())
        
        # Determine first and last weeks
        sorted_weeks = sorted(by_week.keys())
        first_week = sorted_weeks[0] if sorted_weeks else 0
        last_week = sorted_weeks[-1] if sorted_weeks else 0
        
        # Check for violations (excluding first and last weeks)
        for week_num, count in by_week.items():
            # Skip first and last weeks as they have special handling
            if week_num in (first_week, last_week):
                continue
                
            # Check regular weeks against full minimum
            if count < context.request.constraints.minPeriodsPerWeek:
                violations.append(ConstraintViolation(
                    message=(
                        f"Too few classes scheduled in week {week_num + 1}: "
                        f"got {count}, minimum is {context.request.constraints.minPeriodsPerWeek}"
                    ),
                    severity="error",
                    context={
                        "weekNumber": week_num + 1,
                        "count": count,
                        "minimum": context.request.constraints.minPeriodsPerWeek
                    }
                ))
            
            # For first week, check pro-rated minimum if it's not a full week
            if week_num == first_week and len(weekdays_by_week[week_num]) < 5:
                available_days = len(weekdays_by_week[week_num])
                pro_rated_min = (context.request.constraints.minPeriodsPerWeek * available_days) // 5
                
                if count < pro_rated_min:
                    violations.append(ConstraintViolation(
                        message=(
                            f"Too few classes scheduled in first week (pro-rated): "
                            f"got {count}, minimum is {pro_rated_min} "
                            f"({available_days} available days)"
                        ),
                        severity="error",
                        context={
                            "weekNumber": week_num + 1,
                            "count": count,
                            "minimum": pro_rated_min,
                            "availableDays": available_days
                        }
                    ))
        
        return violations

================
File: scheduler-backend/app/scheduling/constraints/periods.py
================
"""Constraints related to period assignments"""
from typing import List
from ..core import Constraint, SchedulerContext
from ...models import ScheduleAssignment
from ...utils.date_utils import to_utc_isoformat

class RequiredPeriodsConstraint(Constraint):
    """Enforce required periods as hard constraints"""
    
    def __init__(self):
        super().__init__("Required Periods")
    
    def apply(self, context: SchedulerContext) -> None:
        """Add hard constraints for required periods"""
        for class_obj in context.request.classes:
            # Look for variables matching this class
            class_vars = [
                var for var in context.variables 
                if var["name"] == class_obj.name
            ]

            # Handle required periods if present
            if class_obj.required_periods:
                for required in class_obj.required_periods:
                    # Find matching variable for this required period
                    matching_vars = [
                        var for var in class_vars
                        if (to_utc_isoformat(var["date"]) == required.date
                            and var["period"] == required.period)
                    ]
                    
                    if matching_vars:
                        # Force assignment to this period
                        context.model.Add(matching_vars[0]["variable"] == 1)
                        
                        # Prevent assignment to any other periods on this day
                        same_day_vars = [
                            var for var in class_vars
                        if (to_utc_isoformat(var["date"]) == required.date
                            and var["period"] != required.period)
                        ]
                        for var in same_day_vars:
                            context.model.Add(var["variable"] == 0)

    def validate(self, assignments: List[ScheduleAssignment], context: SchedulerContext) -> List[str]:
        """Validate that all required periods are satisfied"""
        violations = []

        for class_obj in context.request.classes:
            if not class_obj.required_periods:
                continue

            # Get assignments for this class
            class_assignments = [
                a for a in assignments if a.name == class_obj.name
            ]

            # Check each required period
            for required in class_obj.required_periods:
                matching = [
                    a for a in class_assignments
                    if (a.date == required.date
                        and a.timeSlot.period == required.period)
                ]

                if not matching:
                    violations.append(
                        f"Class {class_obj.name} is missing required assignment "
                        f"on {required.date} period {required.period}"
                    )

        return violations

class ConflictPeriodsConstraint(Constraint):
    """Prevent assignments to conflicting periods"""

    def __init__(self):
        super().__init__("Conflict Periods")

    def apply(self, context: SchedulerContext) -> None:
        """Add constraints to prevent assignment to conflicting periods"""
        for class_obj in context.request.classes:
            if not class_obj.conflicts:
                continue

            # Get all variables for this class
            class_vars = [
                var for var in context.variables 
                if var["name"] == class_obj.name
            ]

            # Prevent assignment to any conflicting periods
            for var in class_vars:
                weekday = var["date"].weekday() + 1  # Convert to 1-5 for Monday-Friday
                conflicts = [
                    c for c in class_obj.conflicts
                    if c.dayOfWeek == weekday and c.period == var["period"]
                ]
                if conflicts:
                    context.model.Add(var["variable"] == 0)

    def validate(self, assignments: List[ScheduleAssignment], context: SchedulerContext) -> List[str]:
        """Validate that no assignments violate conflicts"""
        violations = []

        for class_obj in context.request.classes:
            if not class_obj.conflicts:
                continue

            # Check each assignment against conflicts
            class_assignments = [
                a for a in assignments if a.name == class_obj.name
            ]

            for assignment in class_assignments:
                conflicts = [
                    c for c in class_obj.conflicts
                    if (c.dayOfWeek == assignment.timeSlot.dayOfWeek
                        and c.period == assignment.timeSlot.period)
                ]

                if conflicts:
                    violations.append(
                        f"Class {class_obj.name} is assigned to conflicting period "
                        f"on day {assignment.timeSlot.dayOfWeek} "
                        f"period {assignment.timeSlot.period}"
                    )

        return violations

================
File: scheduler-backend/app/scheduling/constraints/teacher.py
================
from collections import defaultdict
from typing import List, Dict, Any, Set, Tuple
from datetime import datetime
from dateutil.tz import UTC

from ortools.sat.python import cp_model

from .base import BaseConstraint, ConstraintViolation
from ..core import SchedulerContext

class InstructorAvailabilityConstraint(BaseConstraint):
    """Ensures classes are only scheduled when instructor is available"""
    
    def __init__(self):
        super().__init__("instructor_availability")
        
    def apply(self, context: SchedulerContext) -> None:
        # Build lookup of unavailable periods
        unavailable_slots: Dict[str, Set[int]] = defaultdict(set)
        for avail in context.request.instructorAvailability:
            avail_date = datetime.fromisoformat(avail.date)
            if avail_date.tzinfo is None:
                avail_date = avail_date.replace(tzinfo=UTC)
                
            date_str = avail_date.date().isoformat()
            unavailable_slots[date_str].update(avail.periods)
        
        # Add constraints for each variable that would be during an unavailable period
        unavailable_count = 0
        for var in context.variables:
            date_str = var["date"].date().isoformat()
            if date_str in unavailable_slots and var["period"] in unavailable_slots[date_str]:
                context.model.Add(var["variable"] == 0)
                unavailable_count += 1
        
        print(f"Added {unavailable_count} instructor availability constraints")
    
    def validate(
        self,
        assignments: List[Dict[str, Any]],
        context: SchedulerContext
    ) -> List[ConstraintViolation]:
        violations = []
        
        # Build lookup of unavailable periods
        unavailable_slots: Dict[str, Set[int]] = defaultdict(set)
        for avail in context.request.instructorAvailability:
            avail_date = datetime.fromisoformat(avail.date)
            if avail_date.tzinfo is None:
                avail_date = avail_date.replace(tzinfo=UTC)
                
            date_str = avail_date.date().isoformat()
            unavailable_slots[date_str].update(avail.periods)
        
        # Check each assignment
        for assignment in assignments:
            date = datetime.fromisoformat(assignment.date).date().isoformat()
            period = assignment.timeSlot.period
            
            if date in unavailable_slots and period in unavailable_slots[date]:
                violations.append(ConstraintViolation(
                    message=(
                        f"Class {assignment.name} scheduled during "
                        f"unavailable period {period} on {date}"
                    ),
                    severity="error",
                    context={
                        "name": assignment.name,
                        "date": date,
                        "period": period
                    }
                ))
        
        return violations


class TeacherLoadConstraint(BaseConstraint):
    """Ensures a teacher does not exceed maximum classes per day and per week."""
    
    def __init__(self, max_classes_per_day: int = 3, max_classes_per_week: int = 12):
        super().__init__("teacher_load")
        self.max_classes_per_day = max_classes_per_day
        self.max_classes_per_week = max_classes_per_week

    def apply(self, context: SchedulerContext) -> None:
        from collections import defaultdict
        teacher_daily = defaultdict(list)
        teacher_weekly = defaultdict(list)
        # Group variables by teacher and day, and teacher and week (using ISO week number)
        for var in context.variables:
            teacher = var.get("teacher")
            if teacher:
                day = var["date"].date()
                teacher_daily[(teacher, day)].append(var["variable"])
                week = var["date"].isocalendar()[1]
                teacher_weekly[(teacher, week)].append(var["variable"])
        # Add constraints for daily limits
        for (teacher, day), variables in teacher_daily.items():
            context.model.Add(sum(variables) <= self.max_classes_per_day)
        # Add constraints for weekly limits
        for (teacher, week), variables in teacher_weekly.items():
            context.model.Add(sum(variables) <= self.max_classes_per_week)
        print("Added teacher load constraints")
    
    def validate(self, assignments: List[Dict[str, Any]], context: SchedulerContext) -> List[ConstraintViolation]:
        violations = []
        # Placeholder: add logic to validate teacher load constraints if needed
        return violations

================
File: scheduler-backend/app/scheduling/objectives/__init__.py
================
from .base import BaseObjective
from .required import RequiredPeriodsObjective
from .distribution import DistributionObjective, DistributionMetrics

__all__ = [
    'BaseObjective',
    'RequiredPeriodsObjective',
    'DistributionObjective',
    'DistributionMetrics'
]

================
File: scheduler-backend/app/scheduling/objectives/base.py
================
from abc import ABC, abstractmethod
from typing import List

from ortools.sat.python import cp_model

from ..core import SchedulerContext

class BaseObjective(ABC):
    """Base class for implementing scheduling objectives"""
    
    def __init__(self, name: str, weight: int):
        self._name = name
        self._weight = weight
        
    @property
    def name(self) -> str:
        """Get the objective's name for logging"""
        return self._name
    
    @property
    def weight(self) -> int:
        """Get the objective's weight for the solver"""
        return self._weight
    
    @abstractmethod
    def create_terms(self, context: SchedulerContext) -> List[cp_model.LinearExpr]:
        """Create objective terms for the solver"""
        pass

================
File: scheduler-backend/app/scheduling/objectives/daily_balance.py
================
"""Objective to encourage similar number of classes across used days"""
from collections import defaultdict
from typing import List, Dict, Any
from datetime import datetime, timedelta

from ortools.sat.python import cp_model

from .base import BaseObjective
from ..core import SchedulerContext
from ...models import ScheduleAssignment

class DailyBalanceObjective(BaseObjective):
    """Encourages similar number of classes on each used day"""
    
    def __init__(self):
        from ..solvers.config import WEIGHTS
        super().__init__(
            name="daily_balance",
            weight=WEIGHTS['daily_balance']
        )
    
    def create_terms(self, context: SchedulerContext) -> List[cp_model.LinearExpr]:
        terms = []
        
        # Group variables by week and day
        by_week = defaultdict(lambda: defaultdict(list))
        for var in context.variables:
            week_num = (var["date"] - context.start_date).days // 7
            day_num = var["date"].weekday()  # Monday = 0, Sunday = 6
            by_week[week_num][day_num].append(var)
        
        # Process each week (except final week)
        total_weeks = max(by_week.keys()) + 1
        for week_num in range(total_weeks - 1):  # Skip final week
            week_vars = by_week[week_num]
            
            # Create day usage indicators and class counts
            day_used = {}
            day_count = {}
            
            # For each weekday (Monday-Friday)
            for day_num in range(5):  # 0-4 represents Monday-Friday
                if day_num in week_vars:
                    # Binary variable indicating if day is used
                    day_used[day_num] = context.model.NewBoolVar(
                        f"balance_day_used_w{week_num}_d{day_num}"
                    )
                    
                    # Sum of assignments for this day
                    day_sum = sum(var["variable"] for var in week_vars[day_num])
                    day_count[day_num] = day_sum
                    
                    # Link day_used to whether any classes are scheduled
                    context.model.Add(day_sum > 0).OnlyEnforceIf(day_used[day_num])
                    context.model.Add(day_sum == 0).OnlyEnforceIf(day_used[day_num].Not())
            
            # Compare each pair of used days
            for day_i in range(5):
                if day_i not in week_vars:
                    continue
                    
                for day_j in range(day_i + 1, 5):
                    if day_j not in week_vars:
                        continue
                        
                    # Create deviation variable for this pair
                    deviation = context.model.NewIntVar(
                        -10, 10,
                        f"daily_balance_dev_w{week_num}_d{day_i}_{day_j}"
                    )
                    
                    # Calculate difference in class count
                    context.model.Add(
                        deviation == day_count[day_i] - day_count[day_j]
                    )
                    
                    # Penalize differences between used days
                    penalty = context.model.NewIntVar(
                        -1000, 0,
                        f"daily_balance_penalty_w{week_num}_d{day_i}_{day_j}"
                    )
                    
                    # Only apply penalty if both days are used
                    context.model.Add(
                        penalty == -100 * deviation
                    ).OnlyEnforceIf([day_used[day_i], day_used[day_j]])
                    context.model.Add(
                        penalty == -100 * -deviation
                    ).OnlyEnforceIf([day_used[day_i], day_used[day_j]])
                    context.model.Add(
                        penalty == 0
                    ).OnlyEnforceIf([day_used[day_i].Not()])
                    context.model.Add(
                        penalty == 0
                    ).OnlyEnforceIf([day_used[day_j].Not()])
                    
                    terms.append(penalty)
        
        return terms

================
File: scheduler-backend/app/scheduling/objectives/day_usage.py
================
"""Objective to encourage using all available days in each week"""
from collections import defaultdict
from typing import List, Dict, Any
from datetime import datetime, timedelta

from ortools.sat.python import cp_model

from .base import BaseObjective
from ..core import SchedulerContext
from ...models import ScheduleAssignment

class DayUsageObjective(BaseObjective):
    """Encourages spreading classes across all available days in a week"""
    
    def __init__(self):
        from ..solvers.config import WEIGHTS
        super().__init__(
            name="day_usage",
            weight=WEIGHTS['day_usage']
        )
    
    def create_terms(self, context: SchedulerContext) -> List[cp_model.LinearExpr]:
        terms = []
        
        # Group variables by week and day
        by_week = defaultdict(lambda: defaultdict(list))
        for var in context.variables:
            week_num = (var["date"] - context.start_date).days // 7
            day_num = var["date"].weekday()  # Monday = 0, Sunday = 6
            by_week[week_num][day_num].append(var)
        
        # For each week (except final week), encourage using all weekdays
        total_weeks = max(by_week.keys()) + 1
        for week_num in range(total_weeks - 1):  # Skip final week
            week_vars = by_week[week_num]
            
            # For each weekday (Monday-Friday)
            for day_num in range(5):  # 0-4 represents Monday-Friday
                if day_num in week_vars:
                    # Create binary variable indicating if day is used
                    day_used = context.model.NewBoolVar(f"day_used_w{week_num}_d{day_num}")
                    
                    # Sum of assignments for this day
                    day_sum = sum(var["variable"] for var in week_vars[day_num])
                    
                    # Link day_used to whether any classes are scheduled
                    context.model.Add(day_sum > 0).OnlyEnforceIf(day_used)
                    context.model.Add(day_sum == 0).OnlyEnforceIf(day_used.Not())
                    
                    # Add penalty for unused days
                    penalty = context.model.NewIntVar(-1000, 0, f"day_penalty_w{week_num}_d{day_num}")
                    context.model.Add(penalty == day_used.Not() * -1000)
                    terms.append(penalty)
        
        return terms

================
File: scheduler-backend/app/scheduling/objectives/distribution.py
================
from collections import defaultdict
from typing import List, Dict, Any
from dataclasses import dataclass
import statistics
from datetime import datetime, timedelta

from ortools.sat.python import cp_model

from .base import BaseObjective
from ..core import SchedulerContext
from ...models import ScheduleAssignment

@dataclass
class DistributionMetrics:
    """Tracks distribution metrics for schedule analysis"""
    classes_per_week: Dict[int, int]
    classes_per_period: Dict[str, Dict[str, int]]  # Changed inner Dict key to str
    class_periods: Dict[str, Dict[str, int]]
    week_variance: float
    period_spread: Dict[str, float]
    class_load_variance: Dict[str, float]
    distribution_score: float

    @property
    def teacher_load_variance(self) -> Dict[str, float]:
        # For backward compatibility. Previously, workload variance was referred to as teacher_load_variance.
        return self.class_load_variance

class DistributionObjective(BaseObjective):
    """
    Objective function for optimizing schedule distribution:
    1. Even distribution across weeks
    2. Even distribution within days
    3. Balanced class workload
    """
    
    def __init__(self):
        from ..solvers.config import WEIGHTS
        super().__init__(
            name="distribution",
            weight=WEIGHTS['distribution']  # Use standardized weight from config
        )
    
    def create_terms(self, context: SchedulerContext) -> List[cp_model.LinearExpr]:
        terms = []
        
        # Group variables by week
        by_week = defaultdict(list)
        for var in context.variables:
            # Both var["date"] and context.start_date are datetime objects from base solver
            week_num = (var["date"] - context.start_date).days // 7
            by_week[week_num].append(var)
        
        # Create weekly distribution terms
        total_classes = len(context.request.classes)
        total_weeks = len(by_week)
        # Scale up by 100 to handle decimals as integers
        target_per_week = (total_classes * 100) // total_weeks
        
        for week_vars in by_week.values():
            # Sum of assignments for this week (scaled up)
            week_sum = sum(100 * var["variable"] for var in week_vars)
            # Penalize deviation from target
            deviation = context.model.NewIntVar(-1000, 1000, "week_deviation")
            context.model.Add(deviation == week_sum - target_per_week)
            # Use linear penalty
            penalty = context.model.NewIntVar(-750000, 0, "week_penalty")
            # Absolute value of deviation using two constraints
            context.model.Add(penalty <= -750 * deviation)
            context.model.Add(penalty <= 750 * deviation)
            terms.append(penalty)
        
        # Group variables by date and period
        by_date = defaultdict(lambda: defaultdict(list))
        for var in context.variables:
            date = var["date"].date()
            period = var["period"]
            by_date[date][period].append(var)
        
        # Create daily distribution terms
        for date, periods in by_date.items():
            # Track assignments per period
            period_sums = []
            for period in range(1, 9):
                if period in periods:
                    period_sum = sum(
                        var["variable"] for var in periods[period]
                    )
                    period_sums.append(period_sum)
            
            # Penalize uneven distribution across periods
            if period_sums:
                for i in range(len(period_sums)):
                    for j in range(i + 1, len(period_sums)):
                        # Create deviation variable for each pair
                        deviation = context.model.NewIntVar(
                            -10, 10, 
                            f"period_diff_{date}_{i}_{j}"
                        )
                        context.model.Add(
                            deviation == period_sums[i] - period_sums[j]
                        )
                        # Penalize differences
                        penalty = context.model.NewIntVar(
                            -500, 0,
                            f"period_penalty_{date}_{i}_{j}"
                        )
                        context.model.Add(penalty <= -50 * deviation)
                        context.model.Add(penalty <= 50 * deviation)
                        terms.append(penalty)
        
        # Group variables by class
        by_class = defaultdict(lambda: defaultdict(list))
        for var in context.variables:
            date = var["date"].date()
            by_class[var["name"]][date].append(var)
        
        # Create class workload distribution terms
        for class_vars in by_class.values():
            for date, day_vars in class_vars.items():
                # Sum of assignments for this class on this day
                day_sum = sum(var["variable"] for var in day_vars)
                # Penalty increases with number of classes
                penalty = context.model.NewIntVar(
                    -1000, 0,
                    f"class_penalty_{date}"
                )
                context.model.Add(penalty == -250 * day_sum)
                terms.append(penalty)
        
        # Store metrics for debug info
        context.debug_info["distribution"] = {
            "targetClassesPerWeek": target_per_week / 100,  # Scale back down
            "totalClasses": total_classes,
            "totalWeeks": total_weeks
        }
        
        return terms
    
    def calculate_metrics(
        self,
        assignments: List[ScheduleAssignment],
        context: SchedulerContext
    ) -> DistributionMetrics:
        """Calculate distribution metrics for assigned schedule"""
        classes_per_week = defaultdict(int)
        classes_per_period = defaultdict(lambda: defaultdict(int))
        class_periods = defaultdict(lambda: defaultdict(int))
        
        print("\nCalculating distribution metrics...")
        print(f"Total assignments: {len(assignments)}")
        
        # Group assignments and calculate metrics
        for assignment in assignments:
            try:
                # Parse the ISO format date string into a datetime object
                date = datetime.fromisoformat(assignment.date)
                period = assignment.timeSlot.period
                class_name = assignment.name
                
                # Calculate week number using datetime objects
                week_num = (date - context.start_date).days // 7
                classes_per_week[week_num] += 1
                
                # Use date string for dictionary keys
                date_str = date.date().isoformat()
                period_str = str(period)  # Convert period to string
                
                # Daily distribution
                classes_per_period[date_str][period_str] += 1  # Use string key
                class_periods[date_str][class_name] += 1
                
                print(f"Processed assignment: date={date_str}, period={period_str}, class={class_name}, week={week_num}")
                
            except Exception as e:
                print(f"Error processing assignment: {assignment}")
                print(f"Error details: {str(e)}")
                raise
        
        print("\nWeekly distribution:")
        for week, count in classes_per_week.items():
            print(f"Week {week}: {count} classes")
        
        # Calculate variances and spreads
        week_counts = list(classes_per_week.values())
        week_variance = (
            statistics.variance(week_counts)
            if len(week_counts) > 1
            else 0.0
        )
        
        # Calculate period spread for each day
        period_spread = {}
        for date_str, periods in classes_per_period.items():
            # Convert period numbers to strings when accessing
            counts = [periods.get(str(p), 0) for p in range(1, 9)]
            variance = (
                statistics.variance(counts)
                if len(counts) > 1
                else 0.0
            )
            # Convert to spread score (1 - normalized variance)
            max_variance = 4.0  # Theoretical maximum
            period_spread[date_str] = 1.0 - min(variance / max_variance, 1.0)
        
        # Calculate class load variance for each day
        class_load_variance = {}
        for date_str, loads in class_periods.items():
            counts = list(loads.values())
            class_load_variance[date_str] = (
                statistics.variance(counts)
                if len(counts) > 1
                else 0.0
            )
        
        # Calculate overall distribution score
        total_score = 0
        for date_str in classes_per_period.keys():
            # Penalize poor period spread
            spread_penalty = -200 * (1.0 - period_spread[date_str])
            # Penalize class load imbalance
            load_penalty = -150 * class_load_variance.get(date_str, 0.0)
            total_score += spread_penalty + load_penalty
        
        # Penalize weekly variance
        total_score += -100 * week_variance
        
        print("\nDistribution metrics calculated:")
        print(f"Week variance: {week_variance}")
        print(f"Total score: {total_score}")
        
        return DistributionMetrics(
            classes_per_week=dict(classes_per_week),
            classes_per_period=dict(classes_per_period),
            class_periods=dict(class_periods),
            week_variance=week_variance,
            period_spread=dict(period_spread),
            class_load_variance=dict(class_load_variance),
            distribution_score=total_score
        )

================
File: scheduler-backend/app/scheduling/objectives/final_week.py
================
"""Objective to compress remaining classes into early days of final week"""
from collections import defaultdict
from typing import List, Dict, Any
from datetime import datetime, timedelta

from ortools.sat.python import cp_model

from .base import BaseObjective
from ..core import SchedulerContext
from ...models import ScheduleAssignment

class FinalWeekCompressionObjective(BaseObjective):
    """Encourages scheduling final week classes as early as possible"""
    
    def __init__(self):
        from ..solvers.config import WEIGHTS
        super().__init__(
            name="final_week_compression",
            weight=WEIGHTS['final_week_compression']
        )
    
    def create_terms(self, context: SchedulerContext) -> List[cp_model.LinearExpr]:
        terms = []
        
        # Group variables by week and day
        by_week = defaultdict(lambda: defaultdict(list))
        for var in context.variables:
            week_num = (var["date"] - context.start_date).days // 7
            day_num = var["date"].weekday()  # Monday = 0, Sunday = 6
            by_week[week_num][day_num].append(var)
        
        # Only focus on the final week
        final_week = max(by_week.keys())
        if final_week in by_week:
            final_week_vars = by_week[final_week]
            
            # For each weekday (Monday-Friday)
            for day_num in range(5):  # 0-4 represents Monday-Friday
                if day_num in final_week_vars:
                    day_vars = final_week_vars[day_num]
                    
                    # Create weighted penalty based on day number
                    # Earlier days get less penalty
                    for var in day_vars:
                        # Scale penalty by day number (0 for Monday, increasing for later days)
                        day_penalty = context.model.NewIntVar(
                            -1000, 0, 
                            f"final_week_day_penalty_d{day_num}_c{var['name']}"
                        )
                        # Penalty increases for later days
                        context.model.Add(
                            day_penalty == var["variable"] * -200 * (day_num + 1)
                        )
                        terms.append(day_penalty)
                        
                    # Additional penalty for gaps between used days
                    if day_num > 0 and day_num - 1 in final_week_vars:
                        # Variables for previous and current day usage
                        prev_day_used = context.model.NewBoolVar(
                            f"final_week_prev_day_used_{day_num}"
                        )
                        curr_day_used = context.model.NewBoolVar(
                            f"final_week_curr_day_used_{day_num}"
                        )
                        
                        # Link usage variables to assignments
                        prev_sum = sum(
                            var["variable"] 
                            for var in final_week_vars[day_num - 1]
                        )
                        curr_sum = sum(
                            var["variable"] 
                            for var in final_week_vars[day_num]
                        )
                        
                        context.model.Add(prev_sum > 0).OnlyEnforceIf(prev_day_used)
                        context.model.Add(prev_sum == 0).OnlyEnforceIf(prev_day_used.Not())
                        context.model.Add(curr_sum > 0).OnlyEnforceIf(curr_day_used)
                        context.model.Add(curr_sum == 0).OnlyEnforceIf(curr_day_used.Not())
                        
                        # Penalize gaps (prev day unused but current day used)
                        gap_penalty = context.model.NewIntVar(
                            -1000, 0,
                            f"final_week_gap_penalty_{day_num}"
                        )
                        # Penalty if we skip a day but use a later one
                        context.model.Add(
                            gap_penalty == -500
                        ).OnlyEnforceIf([prev_day_used.Not(), curr_day_used])
                        context.model.Add(
                            gap_penalty == 0
                        ).OnlyEnforceIf([prev_day_used.Not(), curr_day_used.Not()])
                        context.model.Add(
                            gap_penalty == 0
                        ).OnlyEnforceIf([prev_day_used])
                        
                        terms.append(gap_penalty)
        
        return terms

================
File: scheduler-backend/app/scheduling/objectives/required.py
================
from typing import List
from dateutil import parser
from dateutil.tz import UTC

from ortools.sat.python import cp_model

from .base import BaseObjective
from ..core import SchedulerContext

class RequiredPeriodsObjective(BaseObjective):
    """
    Objective function prioritizing:
    1. Required period assignments (highest priority)
    2. Early scheduling in last week (medium priority)
    3. Earlier dates (lowest priority)
    """
    
    def __init__(self):
        super().__init__(
            name="required_periods",
            weight=1000  # High weight since this is primary objective
        )
    
    def create_terms(self, context: SchedulerContext) -> List[cp_model.LinearExpr]:
        terms = []
        start_date = context.start_date
        
        # Add early scheduling variables from context
        early_vars = context.debug_info.get("early_scheduling_vars", [])
        for var in early_vars:
            # Weight of 5000 puts this between required periods (10000) and other objectives
            terms.append(5000 * var)
        
        for var in context.variables:
            # Get class object for this variable
            class_obj = next(
                c for c in context.request.classes 
                if c.name == var["name"]
            )
            
            # Convert variable's date to date string
            date_str = var["date"].date().isoformat()
            period = var["period"]
            
            # Check if this is a required period
            is_required = any(
                rp.date == date_str and rp.period == period
                for rp in class_obj.required_periods
            )
            
            if is_required:
                # Large reward for required periods (highest priority)
                terms.append(10000 * var["variable"])
                
            # Small reward for earlier dates (lowest priority)
            days_from_start = (var["date"] - start_date).days
            date_weight = 10 - days_from_start * 0.1
            terms.append(int(date_weight) * var["variable"])
        
        return terms

================
File: scheduler-backend/app/scheduling/solvers/__init__.py
================
from .stable import StableSolver
from .dev import DevSolver

__all__ = ['StableSolver', 'DevSolver']

================
File: scheduler-backend/app/scheduling/solvers/base.py
================
from typing import List, Dict, Any, Optional
import traceback
import time
from datetime import datetime, timedelta

from ortools.sat.python import cp_model

from ..core import SchedulerContext
from ...models import (
    ScheduleRequest, 
    ScheduleResponse, 
    ScheduleAssignment, 
    TimeSlot,
    ScheduleMetadata,
    DistributionMetrics,
    WeeklyDistributionMetrics,
    DailyDistributionMetrics
)
from dateutil.tz import UTC

class BaseSolver:
    """Base solver implementation with common functionality"""
    
    def __init__(self, name: str):
        self.name = name
        self.constraints = []
        self.objectives = []
        
    def add_constraint(self, constraint: Any) -> None:
        """Add a constraint to the solver"""
        self.constraints.append(constraint)
        
    def add_objective(self, objective: Any) -> None:
        """Add an objective to the solver"""
        self.objectives.append(objective)
        
    def create_schedule(self, request: ScheduleRequest) -> ScheduleResponse:
        """Create a schedule using the solver configuration"""
        print(f"\nStarting {self.name} solver for {len(request.classes)} classes...")
        print("\nSolver configuration:")
        print("Constraints:")
        for constraint in self.constraints:
            print(f"- {constraint.name}")
        print("\nObjectives:")
        for objective in self.objectives:
            print(f"- {objective.name} (weight: {objective.weight})")
            
        try:
            # Create solver and model
            model = cp_model.CpModel()
            solver = cp_model.CpSolver()
            
            # Configure solver parameters for timeout and performance
            solver.parameters.max_time_in_seconds = 120.0  # 2 minute timeout
            solver.parameters.log_search_progress = True
            solver.parameters.num_search_workers = 8
            
            # Parse dates
            start_date = datetime.fromisoformat(request.startDate)
            end_date = datetime.fromisoformat(request.endDate)
            if start_date.tzinfo is None:
                start_date = start_date.replace(tzinfo=UTC)
            if end_date.tzinfo is None:
                end_date = end_date.replace(tzinfo=UTC)
            
            # Create context
            context = SchedulerContext(
                model=model,
                solver=solver,
                request=request,
                start_date=start_date,
                end_date=end_date
            )
            
            # Create variables
            self._create_variables(context)
            print(f"\nCreated {len(context.variables)} schedule variables")
            
            # Log available slots per class
            print("\nAvailable slots per class:")
            by_class = {}
            for var in context.variables:
                class_name = var["name"]
                if class_name not in by_class:
                    by_class[class_name] = []
                by_class[class_name].append(var)
            
            for class_name, vars_list in by_class.items():
                print(f"\nClass {class_name}:")
                print(f"- Total available slots: {len(vars_list)}")
                # Get class's conflicts
                class_obj = next(c for c in request.classes if c.name == class_name)
                print(f"- Conflict periods: {len(class_obj.conflicts)}")
                # Group by day
                by_day = {}
                for var in vars_list:
                    day = var["date"].strftime("%Y-%m-%d")
                    if day not in by_day:
                        by_day[day] = []
                    by_day[day].append(var["period"])
                for day, periods in by_day.items():
                    print(f"  {day}: periods {sorted(periods)}")
            
            # Apply constraints
            for constraint in self.constraints:
                print(f"\nApplying constraint: {constraint.name}")
                constraint.apply(context)
            
            # Create objective function
            objective_terms = []
            for objective in self.objectives:
                print(f"\nAdding objective: {objective.name} (weight: {objective.weight})")
                terms = objective.create_terms(context)
                weighted_terms = [objective.weight * term for term in terms]
                objective_terms.extend(weighted_terms)
                
            if objective_terms:
                context.model.Maximize(sum(objective_terms))
            
            # Add search heuristics
            print("\nAdding search heuristics...")
            
            # Get all variables in a flat list
            all_vars = [var["variable"] for var in context.variables]
            
            # Count conflicts per class to identify most constrained classes
            conflicts_by_class = {}
            for class_obj in context.request.classes:
                conflicts_by_class[class_obj.name] = len(class_obj.conflicts)
            
            # Sort variables by number of conflicts (most constrained first)
            sorted_vars = sorted(
                context.variables,
                key=lambda v: (-conflicts_by_class[v["name"]], v["date"].toordinal(), v["period"])
            )
            sorted_var_list = [v["variable"] for v in sorted_vars]
            
            # Add decision strategy
            print("Adding decision strategy:")
            print("1. Try most constrained classes first")
            print("2. Try earlier dates before later dates")
            print("3. Try earlier periods before later periods")
            context.model.AddDecisionStrategy(
                sorted_var_list,
                cp_model.CHOOSE_FIRST,  # Try variables in the order we sorted them
                cp_model.SELECT_MIN_VALUE  # Try false (0) before true (1) to avoid unnecessary assignments
            )
            
            # Create solution callback to track best solution
            callback = SolutionCallback(context)
            
            # Solve with timeout
            print("\nStarting solver with 2 minute timeout...")
            start_time = time.time()
            status = solver.Solve(context.model, callback)
            duration_ms = int((time.time() - start_time) * 1000)
            
            # Check solution status and get best solution within time limit
            solution_found = False
            if status == cp_model.OPTIMAL:
                print("Found optimal solution!")
                solution_found = True
            elif status == cp_model.FEASIBLE:
                print("Found feasible solution within time limit")
                solution_found = True
            elif callback._solutions > 0:
                print("Time limit reached, using best solution found")
                solution_found = True
                status = cp_model.FEASIBLE  # Use best feasible solution found
            else:
                raise Exception("No solution found within time limit")
            
            # Convert solution to assignments using best solution found
            assignments = callback.get_best_solution()
            
            # Get distribution metrics if available
            distribution_metrics = None
            distribution_obj = next(
                (obj for obj in self.objectives if obj.__class__.__name__ == "DistributionObjective"),
                None
            )
            if distribution_obj and hasattr(distribution_obj, "calculate_metrics"):
                metrics = distribution_obj.calculate_metrics(assignments, context)
                
                # Convert classesPerWeek keys to strings
                classes_per_week_str = {str(k): v for k, v in metrics.classes_per_week.items()}
                
                distribution_metrics = DistributionMetrics(
                    weekly=WeeklyDistributionMetrics(
                        variance=metrics.week_variance,
                        classesPerWeek=classes_per_week_str,
                        score=-100 * metrics.week_variance  # Penalize variance
                    ),
                    daily={
                        date: DailyDistributionMetrics(
                            periodSpread=spread,
                            teacherLoadVariance=metrics.teacher_load_variance.get(date, 0.0),
                            classesByPeriod=dict(metrics.classes_per_period.get(date, {}))  # Already string keys
                        )
                        for date, spread in metrics.period_spread.items()
                    },
                    totalScore=metrics.distribution_score
                )
            
            # Create metadata using best objective value
            metadata = ScheduleMetadata(
                duration_ms=duration_ms,
                solutions_found=callback._solutions,
                score=int(callback._best_objective if objective_terms else 0),
                gap=float(
                    (callback._best_objective - solver.BestObjectiveBound()) / 
                    abs(callback._best_objective)
                    if callback._best_objective != 0
                    else 0.0
                )
            )
            
            print("\nSolution metrics:")
            print(f"- Duration: {metadata.duration_ms}ms")
            print(f"- Solutions found: {metadata.solutions_found}")
            print(f"- Score: {metadata.score}")
            print(f"- Gap: {metadata.gap:.2%}")
            
            # Validate constraints
            print("\nValidating constraints...")
            all_violations = []
            for constraint in self.constraints:
                violations = constraint.validate(assignments, context)
                if violations:
                    print(f"\nViolations for {constraint.name}:")
                    for v in violations:
                        print(f"- {v}")
                    all_violations.extend(violations)
            
            if all_violations:
                raise Exception(
                    f"Schedule validation failed with {len(all_violations)} violations"
                )
            
            print("\nAll constraints satisfied!")
            return ScheduleResponse(assignments=assignments, metadata=metadata)
            
        except Exception as e:
            print(f"Scheduling error in {self.name} solver: {str(e)}")
            print("Full traceback:")
            print(traceback.format_exc())
            raise

    def _create_variables(self, context: SchedulerContext) -> None:
        """Create CP-SAT variables for each possible assignment"""
        print("\nCreating schedule variables...")
        
        # First count weekdays in range
        current_date = context.start_date
        weekdays = 0
        while current_date <= context.end_date:
            if current_date.weekday() < 5:  # Monday = 0, Friday = 4
                weekdays += 1
            current_date = current_date + timedelta(days=1)
        
        print(f"Schedule range: {context.start_date.date()} to {context.end_date.date()}")
        print(f"Available weekdays: {weekdays}")
        print(f"Total classes: {len(context.request.classes)}")
        print(f"Periods per day: 8")
        print(f"Maximum possible slots: {weekdays * 8}")
        
        # Create variables
        for class_obj in context.request.classes:
            print(f"\nCreating variables for class {class_obj.name}:")
            print(f"- Conflicts: {len(class_obj.conflicts)}")
            
            current_date = context.start_date
            class_vars = 0
            while current_date <= context.end_date:
                # Only create variables for weekdays and non-conflicting periods
                if current_date.weekday() < 5:  # Monday = 0, Friday = 4
                    weekday = current_date.weekday() + 1  # Convert to 1-5 for Monday-Friday
                    
                    # Get conflicts for this day
                    conflicts = {
                        conflict.period
                        for conflict in class_obj.conflicts
                        if conflict.dayOfWeek == weekday
                    }
                    
                    # Create variables only for non-conflicting periods
                    for period in range(1, 9):  # periods 1-8
                        if period not in conflicts:
                            var_name = f"class_{class_obj.name}_{current_date.date()}_{period}"
                            var = context.model.NewBoolVar(var_name)
                            context.variables.append({
                                "variable": var,
                                "name": class_obj.name,
                                "date": current_date,
                                "period": period
                            })
                            class_vars += 1
                current_date = current_date + timedelta(days=1)
            print(f"- Created {class_vars} variables")

class SolutionCallback(cp_model.CpSolverSolutionCallback):
    """Callback to track solver progress and store intermediate solutions"""
    
    def __init__(self, context: SchedulerContext):
        cp_model.CpSolverSolutionCallback.__init__(self)
        self._solutions = 0
        self._start_time = time.time()
        self._last_log_time = time.time()
        self._last_log_count = 0
        self._best_solution: Optional[List[ScheduleAssignment]] = None
        self._best_objective = float('-inf')
        self._context = context
        
    def on_solution_callback(self):
        """Called when solver finds a new solution"""
        self._solutions += 1
        current_time = time.time()
        
        # Track best solution
        objective_value = self.ObjectiveValue()
        if objective_value > self._best_objective:
            self._best_objective = objective_value
            self._best_solution = self._convert_solution()
            
            # Log solution details
            print(f"\nFound better solution {self._solutions} at {current_time - self._start_time:.1f}s")
            print(f"Objective value: {objective_value}")
            
            # Count assignments by day
            by_day = {}
            for assignment in self._best_solution:
                date = datetime.fromisoformat(assignment.date).date()
                if date not in by_day:
                    by_day[date] = []
                by_day[date].append(assignment)
            
            print("\nAssignments by day:")
            for date in sorted(by_day.keys()):
                assignments = by_day[date]
                print(f"{date}: {len(assignments)} classes")
                for assignment in sorted(assignments, key=lambda a: a.timeSlot.period):
                    print(f"  Period {assignment.timeSlot.period}: {assignment.name}")
        
        # Log every 3 seconds
        if (current_time - self._last_log_time) >= 3.0:
            elapsed = current_time - self._start_time
            solutions_since_last = self._solutions - self._last_log_count
            rate = solutions_since_last / (current_time - self._last_log_time)
            
            print(f"\nSearch status at {elapsed:.1f}s:")
            print(f"- Solutions found: {self._solutions} ({rate:.1f} solutions/sec)")
            print(f"- Best objective: {self.BestObjectiveBound()}")
            print(f"- Current objective: {objective_value}")
            if objective_value != 0:
                gap = (
                    (objective_value - self.BestObjectiveBound()) / 
                    abs(objective_value)
                )
                print(f"- Gap: {gap:.2%}")
            
            self._last_log_time = current_time
            self._last_log_count = self._solutions
            
    def _convert_solution(self) -> List[ScheduleAssignment]:
        """Convert current solution to schedule assignments"""
        assignments = []
        
        for var in self._context.variables:
            if self.BooleanValue(var["variable"]):
                assignments.append(
                    ScheduleAssignment(
                        name=var["name"],
                        date=var["date"].isoformat(),
                        timeSlot=TimeSlot(
                            dayOfWeek=var["date"].weekday() + 1,
                            period=var["period"]
                        )
                    )
                )
        
        return assignments
        
    def get_best_solution(self) -> List[ScheduleAssignment]:
        """Get the best solution found so far"""
        if not self._best_solution:
            return []  # No solution found
        return self._best_solution

================
File: scheduler-backend/app/scheduling/solvers/config.py
================
"""Common solver configurations and constants"""
from typing import List, Dict

# Constraints
from ..constraints.assignment import SingleAssignmentConstraint, NoOverlapConstraint
from ..constraints.instructor import InstructorAvailabilityConstraint
from ..constraints.periods import RequiredPeriodsConstraint, ConflictPeriodsConstraint
from ..constraints.limits import (
    DailyLimitConstraint, 
    WeeklyLimitConstraint, 
    MinimumPeriodsConstraint
)

# Objectives
from ..objectives.required import RequiredPeriodsObjective
from ..objectives.distribution import DistributionObjective
from ..objectives.day_usage import DayUsageObjective
from ..objectives.final_week import FinalWeekCompressionObjective
from ..objectives.daily_balance import DailyBalanceObjective

# Base Types
from ..core import Constraint, Objective

def get_base_constraints() -> List[Constraint]:
    """Get the common constraints used by all solvers"""
    return [
        SingleAssignmentConstraint(),
        NoOverlapConstraint(),
        InstructorAvailabilityConstraint(),
        RequiredPeriodsConstraint(),
        ConflictPeriodsConstraint(),
        DailyLimitConstraint(),
        WeeklyLimitConstraint(),
        MinimumPeriodsConstraint(),
    ]

def get_base_objectives() -> List[Objective]:
    """Get the common objectives used by all solvers"""
    return [
        RequiredPeriodsObjective(),     # weight=10000
        DayUsageObjective(),            # weight=2000
        FinalWeekCompressionObjective(),  # weight=3000
        DailyBalanceObjective(),        # weight=1500
        DistributionObjective(),        # weight=1000
    ]

# Default priority weights for different types of constraints/objectives
DEFAULT_WEIGHTS = {
    'final_week_compression': 3000,   # High priority for final week optimization
    'day_usage': 2000,               # Encourage using all available days
    'daily_balance': 1500,           # Balance number of classes per day
    'preferred_periods': 1000,        # Medium priority - try to use preferred periods
    'distribution': 1000,             # Balance the period distribution
    'avoid_periods': -500,            # Penalty for using avoided periods
    'earlier_dates': 10,             # Slight preference for earlier dates
}

# Current weights that can be modified at runtime
WEIGHTS = DEFAULT_WEIGHTS.copy()

def update_weights(new_weights: Dict[str, int]) -> None:
    """Update solver weights at runtime"""
    global WEIGHTS
    WEIGHTS.update(new_weights)

def reset_weights() -> None:
    """Reset weights to default values"""
    global WEIGHTS
    WEIGHTS = DEFAULT_WEIGHTS.copy()

================
File: scheduler-backend/app/scheduling/solvers/dev.py
================
"""Development solver with experimental optimizations"""
from typing import Dict, Any, List
import traceback
from dateutil import parser

from ..core import SchedulerContext
from ..objectives.distribution import DistributionObjective
from .base import BaseSolver
from .config import get_base_constraints, get_base_objectives, WEIGHTS
from ...models import ScheduleRequest, ScheduleResponse, TimeSlot

class DevSolver(BaseSolver):
    """Development solver for testing new optimization strategies"""
    
    def __init__(self):
        super().__init__("cp-sat-dev")
        self._last_run_metadata = None
        
        # Add base constraints and objectives
        for constraint in get_base_constraints():
            self.add_constraint(constraint)
            
        for objective in get_base_objectives():
            self.add_objective(objective)
            
        # Add experimental distribution optimization with configured weight
        self.add_objective(
            DistributionObjective()
        )

    def get_last_run_metrics(self) -> Dict[str, Any]:
        """Get metrics from last solver run"""
        if not self._last_run_metadata:
            return {
                "status": "No runs available",
                "metrics": None
            }
        return {
            "status": "success",
            "metrics": {
                "duration": self._last_run_metadata.duration,
                "score": self._last_run_metadata.score,
                "solutions_found": self._last_run_metadata.solutions_found,
                "optimization_gap": self._last_run_metadata.optimization_gap,
                "distribution": self._last_run_metadata.distribution.dict() if self._last_run_metadata.distribution else None
            }
        }

    def create_schedule(self, request: ScheduleRequest) -> ScheduleResponse:
        """Create a schedule using the development solver configuration"""
        print(f"\nStarting development solver for {len(request.classes)} classes...")
        print("\nSolver configuration:")
        print("Constraints:")
        for constraint in self.constraints:
            print(f"- {constraint.name}")
        print("\nObjectives:")
        for objective in self.objectives:
            print(f"- {objective.name} (weight: {objective.weight})")
            
        try:
            # Validate dates
            start_date = parser.parse(request.startDate)
            end_date = parser.parse(request.endDate)
            
            # Create schedule using base solver
            response = super().create_schedule(request)
            
            # Validate solution
            print("\nValidating constraints...")
            all_violations = []
            context = SchedulerContext(
                model=None,  # Not needed for validation
                solver=None,  # Not needed for validation
                request=request,
                start_date=start_date,
                end_date=end_date
            )
            
            for constraint in self.constraints:
                violations = constraint.validate(
                    response.assignments,
                    context
                )
                if violations:
                    print(f"\nViolations for {constraint.name}:")
                    for v in violations:
                        print(f"- {v.message}")
                    all_violations.extend(violations)
            
            if all_violations:
                raise Exception(
                    f"Schedule validation failed with {len(all_violations)} violations"
                )
            
            print("\nAll constraints satisfied!")
            self._last_run_metadata = response.metadata
            return response

        except Exception as e:
            print(f"Scheduling error in development solver: {str(e)}")
            print("Full traceback:")
            print(traceback.format_exc())
            raise
        
    def compare_with_stable(self, stable_response: ScheduleResponse, dev_response: ScheduleResponse) -> Dict[str, Any]:
        """Compare dev solver results with stable solver"""
        
        # Find assignments that differ between solutions
        stable_assignments = {
            (a.classId, a.date, a.timeSlot.dayOfWeek, a.timeSlot.period): a 
            for a in stable_response.assignments
        }
        dev_assignments = {
            (a.classId, a.date, a.timeSlot.dayOfWeek, a.timeSlot.period): a 
            for a in dev_response.assignments
        }
        
        # Calculate differences
        differences = []
        stable_keys = set(stable_assignments.keys())
        dev_keys = set(dev_assignments.keys())
        
        # Find assignments missing from stable
        for key in dev_keys - stable_keys:
            differences.append({
                "type": "missing_in_stable",
                "classId": key[0],
                "dev": dev_assignments[key],
            })
        
        # Find assignments missing from dev
        for key in stable_keys - dev_keys:
            differences.append({
                "type": "missing_in_dev",
                "classId": key[0],
                "stable": stable_assignments[key],
            })
        
        # Find assignments that differ in timing
        for key in stable_keys & dev_keys:
            if (stable_assignments[key].timeSlot.dayOfWeek != dev_assignments[key].timeSlot.dayOfWeek or
                stable_assignments[key].timeSlot.period != dev_assignments[key].timeSlot.period):
                differences.append({
                    "type": "different_assignment",
                    "classId": key[0],
                    "stable": stable_assignments[key],
                    "dev": dev_assignments[key],
                })
        
        # Compare metrics
        stable_score = stable_response.metadata.distribution.totalScore if stable_response.metadata.distribution else 0
        dev_score = dev_response.metadata.distribution.totalScore if dev_response.metadata.distribution else 0
        
        return {
            "assignment_differences": {
                "total_differences": len(differences),
                "differences": differences
            },
            "metric_differences": {
                "score": dev_score - stable_score,
                "duration": dev_response.metadata.duration - stable_response.metadata.duration,
                "distribution": {
                    "score_difference": dev_score - stable_score,
                    "weekly_variance_difference": (
                        (dev_response.metadata.distribution.weekly["variance"] if dev_response.metadata.distribution else 0) -
                        (stable_response.metadata.distribution.weekly["variance"] if stable_response.metadata.distribution else 0)
                    ),
                    "average_period_spread_difference": (
                        sum(
                            dev_response.metadata.distribution.daily[date]["periodSpread"] if dev_response.metadata.distribution else 0
                            for date in dev_response.metadata.distribution.daily
                        ) / len(dev_response.metadata.distribution.daily) -
                        sum(
                            stable_response.metadata.distribution.daily[date]["periodSpread"] if stable_response.metadata.distribution else 0
                            for date in stable_response.metadata.distribution.daily
                        ) / len(stable_response.metadata.distribution.daily)
                        if stable_response.metadata.distribution and dev_response.metadata.distribution
                        else 0
                    )
                }
            }
        }

================
File: scheduler-backend/app/scheduling/solvers/stable.py
================
"""Stable solver implementation using shared configuration"""
from typing import List
import traceback
from dateutil import parser

from ..core import SchedulerContext
from ...models import ScheduleRequest, ScheduleResponse
from .base import BaseSolver
from .config import get_base_constraints, get_base_objectives

class StableSolver(BaseSolver):
    """Production-ready solver using tried and tested configuration"""
    
    def __init__(self):
        super().__init__("cp-sat-stable")
        
        # Add base constraints and objectives
        for constraint in get_base_constraints():
            self.add_constraint(constraint)
            
        for objective in get_base_objectives():
            self.add_objective(objective)
        
    def create_schedule(self, request: ScheduleRequest) -> ScheduleResponse:
        """Create a schedule using the stable solver configuration"""
        print(f"\nStarting stable solver for {len(request.classes)} classes...")
        print("\nSolver configuration:")
        print("Constraints:")
        for constraint in self.constraints:
            print(f"- {constraint.name}")
        print("\nObjectives:")
        for objective in self.objectives:
            print(f"- {objective.name} (weight: {objective.weight})")
            
        try:
            # Validate dates
            start_date = parser.parse(request.startDate)
            end_date = parser.parse(request.endDate)
            
            # Create schedule using base solver
            response = super().create_schedule(request)
            
            # Validate solution
            print("\nValidating constraints...")
            all_violations = []
            context = SchedulerContext(
                model=None,  # Not needed for validation
                solver=None,  # Not needed for validation
                request=request,
                start_date=start_date,
                end_date=end_date
            )
            
            for constraint in self.constraints:
                violations = constraint.validate(
                    response.assignments,
                    context
                )
                if violations:
                    print(f"\nViolations for {constraint.name}:")
                    for v in violations:
                        print(f"- {v.message}")
                    all_violations.extend(violations)
            
            if all_violations:
                raise Exception(
                    f"Schedule validation failed with {len(all_violations)} violations"
                )
            
            print("\nAll constraints satisfied!")
            return response
            
        except Exception as e:
            print(f"Scheduling error in stable solver: {str(e)}")
            print("Full traceback:")
            print(traceback.format_exc())
            raise

================
File: scheduler-backend/app/scheduling/utils/__init__.py
================
# Scheduling utilities package
# Currently empty but reserved for future utility functions and helpers

================
File: scheduler-backend/app/scheduling/__init__.py
================
# Scheduling package

================
File: scheduler-backend/app/scheduling/core.py
================
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import List, Dict, Any, Protocol
from ortools.sat.python import cp_model

from ..models import (
    ScheduleRequest,
    ScheduleResponse,
    ScheduleAssignment,
    ScheduleMetadata
)

class SchedulerContext:
    """Context object for sharing state between scheduler components"""
    def __init__(
        self,
        model: cp_model.CpModel,
        solver: cp_model.CpSolver,
        request: ScheduleRequest,
        start_date: datetime,
        end_date: datetime
    ):
        self.model = model
        self.solver = solver
        self.request = request
        self.start_date = start_date
        self.end_date = end_date
        self.variables: List[Dict[str, Any]] = []
        self.debug_info: Dict[str, Any] = {}
        
        # Index classes by name for quick lookup
        self.classes_by_name = {
            c.name: c for c in request.classes
        }
        
        # Index instructor availability by date
        self.instructor_unavailable = {}
        for avail in request.instructorAvailability:
            date_str = avail.date.strftime('%Y-%m-%d')
            if date_str not in self.instructor_unavailable:
                self.instructor_unavailable[date_str] = set()
            self.instructor_unavailable[date_str].update(avail.periods)

class Constraint(Protocol):
    """Protocol defining the interface for scheduler constraints"""
    @property
    def name(self) -> str:
        """Get the constraint's name for logging"""
        ...
    
    def apply(self, context: SchedulerContext) -> None:
        """Apply this constraint to the scheduling model"""
        ...

class Objective(Protocol):
    """Protocol defining the interface for scheduler objectives"""
    @property
    def name(self) -> str:
        """Get the objective's name for logging"""
        ...
    
    @property
    def weight(self) -> int:
        """Get the objective's weight for the solver"""
        ...
    
    def create_terms(self, context: SchedulerContext) -> List[cp_model.LinearExpr]:
        """Create objective terms for the solver"""
        ...

class SchedulerBase(ABC):
    """Base class for scheduler implementations"""
    def __init__(self):
        self.constraints: List[Constraint] = []
        self.objectives: List[Objective] = []
        
    def add_constraint(self, constraint: Constraint) -> None:
        """Add a constraint to the scheduler"""
        self.constraints.append(constraint)
        
    def add_objective(self, objective: Objective) -> None:
        """Add an objective to the scheduler"""
        self.objectives.append(objective)
    
    @abstractmethod
    def create_schedule(self, request: ScheduleRequest) -> ScheduleResponse:
        """Create a schedule satisfying all constraints and optimizing objectives"""
        pass

@dataclass
class SchedulerMetrics:
    """Metrics for scheduler performance and results"""
    duration_ms: int
    score: int
    distribution_score: float
    solver_status: str
    solutions_found: int
    optimization_gap: float

class SolverCallback(cp_model.CpSolverSolutionCallback):
    """Base callback class for logging solver progress"""
    def __init__(self):
        cp_model.CpSolverSolutionCallback.__init__(self)
        self._solutions = 0
        self._start_time = datetime.now()
        self._last_log_time = datetime.now()
        self._last_log_count = 0
        
    def on_solution_callback(self):
        """Called when solver finds a new solution"""
        self._solutions += 1
        current_time = datetime.now()
        
        # Log every 3 seconds
        if (current_time - self._last_log_time).total_seconds() >= 3.0:
            elapsed = (current_time - self._start_time).total_seconds()
            solutions_since_last = self._solutions - self._last_log_count
            rate = solutions_since_last / (current_time - self._last_log_time).total_seconds()
            
            print(f"\nSearch status at {elapsed:.1f}s:")
            print(f"- Solutions found: {self._solutions} ({rate:.1f} solutions/sec)")
            print(f"- Best objective: {self.BestObjectiveBound()}")
            print(f"- Current bound: {self.ObjectiveValue()}")
            if self.ObjectiveValue() != 0:
                gap = ((self.ObjectiveValue() - self.BestObjectiveBound()) 
                      / abs(self.ObjectiveValue()))
                print(f"- Gap: {gap:.2%}")
            
            self._last_log_time = current_time
            self._last_log_count = self._solutions

================
File: scheduler-backend/app/utils/date_utils.py
================
from datetime import datetime, timezone

def to_utc_isoformat(dt: datetime) -> str:
    """
    Convert a datetime object to an ISO 8601 formatted string in UTC with a trailing 'Z'.
    If the datetime is naive (i.e. no timezone information), it is assumed to be in UTC.
    """
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    else:
        dt = dt.astimezone(timezone.utc)
    # Use strftime to ensure the 'Z' suffix for UTC.
    return dt.strftime("%Y-%m-%dT%H:%M:%SZ")

================
File: scheduler-backend/app/main.py
================
from fastapi import FastAPI, HTTPException, Request, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import ValidationError
from typing import Dict, Any

from .models import ScheduleRequest, ScheduleResponse, WeightConfig
from .scheduling.solvers.stable import StableSolver
from .scheduling.solvers.dev import DevSolver

description = """
Scheduler API with configurable solver settings.

Required periods are treated as hard constraints and will always be respected.
Other scheduling preferences can be configured through the solver settings.
"""

app = FastAPI(
    title="Class Scheduler API",
    description=description,
    version="2.0.0",
    openapi_tags=[
        {
            "name": "Schedule Generation",
            "description": "Generate and compare class schedules"
        },
        {
            "name": "Solver Configuration",
            "description": "Configure solver weights and preferences. Required times are always respected."
        },
        {
            "name": "System",
            "description": "Health checks and system monitoring"
        }
    ]
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize solvers
stable_solver = StableSolver()
dev_solver = DevSolver()

@app.exception_handler(ValidationError)
async def validation_exception_handler(request: Request, exc: ValidationError):
    """Handle Pydantic validation errors gracefully"""
    errors = []
    for error in exc.errors():
        # Extract meaningful validation information
        loc = " -> ".join(str(l) for l in error["loc"])
        msg = error["msg"]
        ctx = error.get("ctx", {})
        detailed_msg = f"{msg} (at {loc})"
        if ctx:
            detailed_msg += f": {ctx}"
            
        errors.append({
            "location": loc,
            "message": detailed_msg,
            "type": error["type"]
        })
    return JSONResponse(
        status_code=422,
        content={
            "detail": "Validation failed",
            "errors": errors
        }
    )

@app.post(
    "/schedule/stable",
    response_model=ScheduleResponse,
    tags=["Schedule Generation"],
    summary="Generate schedule (stable)",
    description="Create a schedule using the stable (production) solver. Required periods are enforced."
)
async def create_schedule_stable(request: ScheduleRequest) -> ScheduleResponse:
    try:
        response = stable_solver.create_schedule(request)
        # Convert assignment date strings to UTC ISO 8601 format
        from datetime import datetime
        from app.utils.date_utils import to_utc_isoformat
        for assignment in response.assignments:
            assignment.date = to_utc_isoformat(datetime.fromisoformat(assignment.date))
        # Validate response before returning
        return ScheduleResponse(
            assignments=response.assignments,
            metadata=response.metadata
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=422,
            detail={
                "message": "Invalid schedule request or response",
                "errors": [{"msg": err["msg"], "loc": err["loc"]} for err in e.errors()]
            }
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"message": f"Scheduling error: {str(e)}"}
        )

@app.post(
    "/schedule/dev",
    response_model=ScheduleResponse,
    tags=["Schedule Generation"],
    summary="Generate schedule (development)",
    description="Create a schedule using the development solver for testing."
)
async def create_schedule_dev(request: ScheduleRequest) -> ScheduleResponse:
    try:
        response = dev_solver.create_schedule(request)
        # Convert assignment date strings to UTC ISO 8601 format
        from datetime import datetime
        from app.utils.date_utils import to_utc_isoformat
        for assignment in response.assignments:
            assignment.date = to_utc_isoformat(datetime.fromisoformat(assignment.date))
        # Validate response before returning
        return ScheduleResponse(
            assignments=response.assignments,
            metadata=response.metadata
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=422,
            detail={
                "message": "Invalid schedule request or response",
                "errors": [{"msg": err["msg"], "loc": err["loc"]} for err in e.errors()]
            }
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"message": f"Scheduling error: {str(e)}"}
        )

@app.post(
    "/schedule/compare",
    response_model=Dict[str, Any],
    tags=["Schedule Generation"],
    summary="Compare solvers",
    description="Run both solvers and compare their results"
)
async def compare_solvers(request: ScheduleRequest) -> Dict[str, Any]:
    try:
        # Validate and create schedules
        stable_response = stable_solver.create_schedule(request)
        dev_response = dev_solver.create_schedule(request)
        from datetime import datetime
        from app.utils.date_utils import to_utc_isoformat
        for assignment in stable_response.assignments:
            assignment.date = to_utc_isoformat(datetime.fromisoformat(assignment.date))
        for assignment in dev_response.assignments:
            assignment.date = to_utc_isoformat(datetime.fromisoformat(assignment.date))
        
        comparison = dev_solver.compare_with_stable(
            stable_response,
            dev_response
        )
        
        return {
            "stable": stable_response.dict(),
            "dev": dev_response.dict(),
            "comparison": comparison
        }
    except ValidationError as e:
        raise HTTPException(
            status_code=422,
            detail={
                "message": "Invalid schedule request",
                "errors": [{"msg": err["msg"], "loc": err["loc"]} for err in e.errors()]
            }
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"message": f"Comparison error: {str(e)}"}
        )

@app.get(
    "/metrics/dev",
    tags=["System"],
    summary="Development metrics",
    description="Get metrics from the last development solver run"
)
async def get_dev_metrics() -> Dict[str, Any]:
    try:
        return dev_solver.get_last_run_metrics()
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"message": f"Error fetching metrics: {str(e)}"}
        )

@app.get(
    "/health",
    tags=["System"],
    summary="Health check",
    description="Check if the API is running and responsive"
)
async def health_check() -> Dict[str, str]:
    return {"status": "ok"}

@app.post(
    "/solver/config",
    response_model=Dict[str, Any],
    tags=["Solver Configuration"],
    summary="Update solver weights",
    description="""
    Update the weights used by the scheduler for various objectives. 
    Note: Required periods are enforced as hard constraints regardless of weights.
    """
)
async def update_solver_config(config: WeightConfig) -> Dict[str, Any]:
    from .scheduling.solvers.config import update_weights, WEIGHTS
    
    try:
        update_weights(config.weights_dict)
        return {
            "status": "success",
            "message": "Configuration updated successfully",
            "current_weights": WEIGHTS
        }
    except ValidationError as e:
        raise HTTPException(
            status_code=422,
            detail={
                "message": "Invalid weight configuration",
                "errors": [{"msg": err["msg"], "loc": err["loc"]} for err in e.errors()]
            }
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"message": f"Failed to update configuration: {str(e)}"}
        )

@app.post(
    "/solver/config/reset",
    response_model=Dict[str, Any],
    tags=["Solver Configuration"],
    summary="Reset solver configuration",
    description="Reset all solver weights to their default values"
)
async def reset_solver_config() -> Dict[str, Any]:
    from .scheduling.solvers.config import reset_weights, WEIGHTS
    
    try:
        reset_weights()
        return {
            "status": "success",
            "message": "Configuration reset to defaults",
            "current_weights": WEIGHTS
        }
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"message": f"Failed to reset configuration: {str(e)}"}
        )

================
File: scheduler-backend/app/models.py
================
from typing import List, Optional, Dict
from pydantic import BaseModel, Field, RootModel
from datetime import datetime, time

class TimeSlot(BaseModel):
    dayOfWeek: int = Field(..., ge=1, le=5, description="Day of week (1=Monday, 5=Friday)")
    period: int = Field(..., ge=1, le=8, description="Period number (1-8)")
    
    model_config = {
        'json_schema_extra': {
            "example": {
                "dayOfWeek": 1,
                "period": 1
            }
        }
    }

class RequiredPeriod(BaseModel):
    date: str
    period: int = Field(..., ge=1, le=8)
    
    model_config = {
        'json_schema_extra': {
            "example": {
                "date": "2025-02-12",
                "period": 1
            }
        }
    }

class ConflictPeriod(BaseModel):
    dayOfWeek: int = Field(..., ge=1, le=5)
    period: int = Field(..., ge=1, le=8)
    
    model_config = {
        'json_schema_extra': {
            "example": {
                "dayOfWeek": 1,
                "period": 1
            }
        }
    }

class Class(BaseModel):
    name: str
    grade: str = Field(..., description="Grade level (Pre-K through 5)")
    conflicts: List[ConflictPeriod] = []
    required_periods: List[RequiredPeriod] = []
    
    model_config = {
        'json_schema_extra': {
            "example": {
                "name": "PK207",
                "grade": "Pre-K",
                "conflicts": [
                    {"dayOfWeek": 1, "period": 2},
                    {"dayOfWeek": 2, "period": 3}
                ],
                "required_periods": []
            }
        }
    }

class InstructorAvailability(BaseModel):
    date: datetime
    periods: List[int] = Field(..., description="List of periods when the instructor is unavailable")
    
    model_config = {
        'json_schema_extra': {
            "example": {
                "date": "2025-02-12T00:00:00",
                "periods": [1, 2, 3]
            }
        }
    }

class ScheduleConstraints(BaseModel):
    maxClassesPerDay: int
    maxClassesPerWeek: int
    minPeriodsPerWeek: int
    maxConsecutiveClasses: int
    consecutiveClassesRule: str
    startDate: str
    endDate: str
    
    model_config = {
        'json_schema_extra': {
            "example": {
                "maxClassesPerDay": 4,
                "maxClassesPerWeek": 16,
                "minPeriodsPerWeek": 8,
                "maxConsecutiveClasses": 2,
                "consecutiveClassesRule": "soft",
                "startDate": "2025-02-12",
                "endDate": "2025-03-14"
            }
        }
    }

class ScheduleRequest(BaseModel):
    classes: List[Class]
    instructorAvailability: List[InstructorAvailability]
    startDate: str
    endDate: str
    constraints: ScheduleConstraints
    
    model_config = {
        'json_schema_extra': {
            "example": {
                "classes": [],
                "instructorAvailability": [],
                "startDate": "2025-02-12",
                "endDate": "2025-03-14",
                "constraints": {}
            }
        }
    }

class ScheduleAssignment(BaseModel):
    name: str = Field(..., description="Class name (e.g., PK207)")
    date: str
    timeSlot: TimeSlot
    
    model_config = {
        'json_schema_extra': {
            "example": {
                "name": "PK207",
                "date": "2025-02-12",
                "timeSlot": {
                    "dayOfWeek": 1,
                    "period": 1
                }
            }
        }
    }

class ScheduleMetadata(BaseModel):
    duration_ms: int
    solutions_found: int
    score: float
    gap: float
    
    model_config = {
        'json_schema_extra': {
            "example": {
                "duration_ms": 1000,
                "solutions_found": 1,
                "score": -857960000,
                "gap": -1.13
            }
        }
    }

class ScheduleResponse(BaseModel):
    assignments: List[ScheduleAssignment]
    metadata: ScheduleMetadata
    
    model_config = {
        'json_schema_extra': {
            "example": {
                "assignments": [],
                "metadata": {
                    "duration_ms": 1000,
                    "solutions_found": 1,
                    "score": -857960000,
                    "gap": -1.13
                }
            }
        }
    }

class WeeklyDistributionMetrics(BaseModel):
    variance: float
    classesPerWeek: Dict[str, int]
    score: float

class DailyDistributionMetrics(BaseModel):
    periodSpread: float
    teacherLoadVariance: float
    classesByPeriod: Dict[str, int]  # Using str keys for period numbers

class DistributionMetrics(BaseModel):
    weekly: WeeklyDistributionMetrics
    daily: Dict[str, DailyDistributionMetrics]
    totalScore: float

    model_config = {
        'json_schema_extra': {
            "example": {
                "weekly": {
                    "variance": 0.5,
                    "classesPerWeek": {"1": 8, "2": 8, "3": 8, "4": 8},
                    "score": -50.0
                },
                "daily": {
                    "2025-02-12": {
                        "periodSpread": 0.8,
                        "teacherLoadVariance": 0.2,
                        "classesByPeriod": {"1": 2, "2": 1, "3": 1}
                    }
                },
                "totalScore": -75.0
            }
        }
    }

class WeightConfig(BaseModel):
    final_week_compression: int = Field(..., ge=0, le=10000, description="Weight for final week compression")
    day_usage: int = Field(..., ge=0, le=10000, description="Weight for day usage objective")
    daily_balance: int = Field(..., ge=0, le=10000, description="Weight for daily balance objective")
    preferred_periods: int = Field(..., ge=0, le=10000, description="Weight for preferred periods")
    distribution: int = Field(..., ge=0, le=10000, description="Weight for distribution objective")
    avoid_periods: int = Field(..., ge=-10000, le=0, description="Penalty for using avoided periods")
    earlier_dates: int = Field(..., ge=0, le=1000, description="Weight for earlier dates preference")

    model_config = {
        'json_schema_extra': {
            "example": {
                "final_week_compression": 3000,
                "day_usage": 2000,
                "daily_balance": 1500,
                "preferred_periods": 1000,
                "distribution": 1000,
                "avoid_periods": -500,
                "earlier_dates": 10
            }
        }
    }

    @property
    def weights_dict(self) -> dict:
        """Return weights as a dictionary for easy update"""
        return self.dict()

================
File: scheduler-backend/app/test_class_limits.py
================
from datetime import datetime, timedelta
from app.models import (
    ScheduleRequest,
    Class,
    TimeSlot,
    WeeklySchedule,
    TeacherAvailability,
    ScheduleConstraints
)
from app.scheduler import create_schedule_dev

def test_class_limits():
    """Test the class limit constraints"""
    
    # Use the same test data as the frontend
    test_classes = [
        Class(
            id="1-101",
            name="1-101",
            grade="1",
            weeklySchedule=WeeklySchedule(
                conflicts=[
                    TimeSlot(dayOfWeek=1, period=1),  # Monday first period
                    TimeSlot(dayOfWeek=3, period=4),  # Wednesday fourth period
                ],
                preferredPeriods=[
                    TimeSlot(dayOfWeek=2, period=2),  # Tuesday second period
                    TimeSlot(dayOfWeek=4, period=3),  # Thursday third period
                ],
                requiredPeriods=[],
                avoidPeriods=[
                    TimeSlot(dayOfWeek=5, period=7),  # Friday seventh period
                    TimeSlot(dayOfWeek=5, period=8),  # Friday eighth period
                ],
                preferenceWeight=1.5,  # Strong preference for preferred periods
                avoidanceWeight=1.2    # Moderate avoidance weight
            )
        ),
        Class(
            id="2-205",
            name="2-205",
            grade="2",
            weeklySchedule=WeeklySchedule(
                conflicts=[
                    TimeSlot(dayOfWeek=2, period=5),  # Tuesday fifth period
                    TimeSlot(dayOfWeek=4, period=5),  # Thursday fifth period
                ],
                preferredPeriods=[
                    TimeSlot(dayOfWeek=1, period=3),  # Monday third period
                    TimeSlot(dayOfWeek=3, period=3),  # Wednesday third period
                ],
                requiredPeriods=[
                    TimeSlot(dayOfWeek=5, period=2),  # Friday second period
                ],
                avoidPeriods=[],
                preferenceWeight=2.0,  # Very strong preference for period 3
                avoidanceWeight=1.0    # Default avoidance weight
            )
        ),
        Class(
            id="3-301",
            name="3-301",
            grade="3",
            weeklySchedule=WeeklySchedule(
                conflicts=[
                    TimeSlot(dayOfWeek=1, period=6),  # Monday sixth period
                    TimeSlot(dayOfWeek=3, period=6),  # Wednesday sixth period
                    TimeSlot(dayOfWeek=5, period=6),  # Friday sixth period
                ],
                preferredPeriods=[
                    TimeSlot(dayOfWeek=2, period=4),  # Tuesday fourth period
                    TimeSlot(dayOfWeek=4, period=4),  # Thursday fourth period
                ],
                requiredPeriods=[
                    TimeSlot(dayOfWeek=1, period=4)  # Monday fourth period
                ],
                avoidPeriods=[
                    TimeSlot(dayOfWeek=1, period=1),  # Monday first period
                    TimeSlot(dayOfWeek=5, period=8),  # Friday eighth period
                ],
                preferenceWeight=1.0,  # Default preference weight
                avoidanceWeight=2.0    # Strong avoidance weight
            )
        ),
        Class(
            id="K-102",
            name="K-102",
            grade="K",
            weeklySchedule=WeeklySchedule(
                conflicts=[
                    TimeSlot(dayOfWeek=2, period=3),  # Tuesday third period
                    TimeSlot(dayOfWeek=4, period=3),  # Thursday third period
                ],
                preferredPeriods=[
                    TimeSlot(dayOfWeek=1, period=2),  # Monday second period
                    TimeSlot(dayOfWeek=3, period=2),  # Wednesday second period
                    TimeSlot(dayOfWeek=5, period=2),  # Friday second period
                ],
                requiredPeriods=[
                    TimeSlot(dayOfWeek=5, period=2)  # Friday second period
                ],
                avoidPeriods=[],
                preferenceWeight=1.8,  # Strong preference for period 2
                avoidanceWeight=1.0    # Default avoidance weight
            )
        ),
        Class(
            id="PK-A",
            name="PK-A",
            grade="Pre-K",
            weeklySchedule=WeeklySchedule(
                conflicts=[
                    TimeSlot(dayOfWeek=1, period=8),  # Monday eighth period
                    TimeSlot(dayOfWeek=2, period=8),  # Tuesday eighth period
                    TimeSlot(dayOfWeek=3, period=8),  # Wednesday eighth period
                    TimeSlot(dayOfWeek=4, period=8),  # Thursday eighth period
                    TimeSlot(dayOfWeek=5, period=8),  # Friday eighth period
                ],
                preferredPeriods=[
                    TimeSlot(dayOfWeek=1, period=1),  # Monday first period
                    TimeSlot(dayOfWeek=2, period=1),  # Tuesday first period
                    TimeSlot(dayOfWeek=3, period=1),  # Wednesday first period
                    TimeSlot(dayOfWeek=4, period=1),  # Thursday first period
                    TimeSlot(dayOfWeek=5, period=1),  # Friday first period
                ],
                requiredPeriods=[],
                avoidPeriods=[],
                preferenceWeight=2.5,  # Very strong preference for first period
                avoidanceWeight=1.0    # Default avoidance weight
            )
        )
    ]

    # Create schedule request with various constraint configurations
    start_date = datetime.now().strftime("%Y-%m-%d")
    end_date = (datetime.now() + timedelta(days=21)).strftime("%Y-%m-%d")  # 3 weeks to allow flexibility

    # Create teacher availability data - spread across weeks
    test_teacher_availability = []
    
    # Create teacher availability - just lunch breaks
    for week in range(3):  # 3 weeks
        current_date = datetime.strptime(start_date, "%Y-%m-%d") + timedelta(days=7*week)
        for i in range(5):  # Monday to Friday
            test_teacher_availability.append(
                TeacherAvailability(
                    date=current_date.strftime("%Y-%m-%d"),
                    unavailableSlots=[
                        TimeSlot(dayOfWeek=i+1, period=5),  # Lunch break
                    ],
                    preferredSlots=[],
                    avoidSlots=[]
                )
            )
            current_date += timedelta(days=1)

    print("\n=== Testing Hard Consecutive Class Constraints ===")
    request = ScheduleRequest(
        classes=test_classes,
        teacherAvailability=test_teacher_availability,
        startDate=start_date,
        endDate=end_date,
        constraints=ScheduleConstraints(
            maxClassesPerDay=2,  # Consistent with other tests
            maxClassesPerWeek=4,  # Force spreading across weeks
            minPeriodsPerWeek=1,  # Allow flexible weekly scheduling
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    try:
        result = create_schedule_dev(request)
        print("Hard constraint test passed!")
        print_schedule_summary(result.assignments)
    except Exception as e:
        print(f"Hard constraint test failed: {str(e)}")

    print("\n=== Testing Soft Consecutive Class Constraints ===")
    request.constraints.consecutiveClassesRule = "soft"
    request.constraints.maxConsecutiveClasses = 2
    
    try:
        result = create_schedule_dev(request)
        print("Soft constraint test passed!")
        print_schedule_summary(result.assignments)
    except Exception as e:
        print(f"Soft constraint test failed: {str(e)}")

    print("\n=== Testing Daily Class Limits ===")
    request.constraints.maxClassesPerDay = 2  # Strict daily limit
    
    try:
        result = create_schedule_dev(request)
        print("Daily limit test passed!")
        print_schedule_summary(result.assignments)
    except Exception as e:
        print(f"Daily limit test failed: {str(e)}")

    print("\n=== Testing Weekly Class Limits ===")
    request.constraints.maxClassesPerWeek = 4  # Lower max to force spreading across weeks
    request.constraints.minPeriodsPerWeek = 1  # Lower minimum to allow spreading across weeks
    
    try:
        result = create_schedule_dev(request)
        print("Weekly limit test passed!")
        print_schedule_summary(result.assignments)
    except Exception as e:
        print(f"Weekly limit test failed: {str(e)}")

def print_schedule_summary(assignments):
    """Print a summary of the schedule assignments"""
    # Group by date
    by_date = {}
    for assignment in assignments:
        date = assignment.date.split('T')[0]  # Remove time part
        if date not in by_date:
            by_date[date] = []
        by_date[date].append(assignment)
    
    # Print summary
    for date in sorted(by_date.keys()):
        print(f"\nDate: {date}")
        day_assignments = sorted(by_date[date], key=lambda x: x.timeSlot.period)
        for assignment in day_assignments:
            print(f"  Period {assignment.timeSlot.period}: {assignment.classId}")

if __name__ == "__main__":
    test_class_limits()

================
File: scheduler-backend/data/Schedule_From_Json_Corrected.csv
================
Class,Monday,Tuesday,Wednesday,Thursday,Friday
PK207,2,2,4,3,"1, 3"
PK214,"2, 5","3, 5","1, 5","5, 7","2, 3, 5"
PK208,"2, 5","7, 5","2, 5","2, 5","3, 5, 7"
PK213,"2, 6","1, 6","6, 8","2, 6","3, 4, 6"
PK209,"4, 6","6, 6","2, 8","1, 6","2, 3, 6"
K-313,1,4,"2, 4",4,8
K-309,1,7,"2, 7",3,1
K-311,1,7,"2, 7",1,3
K-310,1,4,"2, 7",4,2
K-312,1,4,"2, 4",7,3
1-407,2,1,1,"2, 4",7
1-409,4,1,3,"2, 5",4
1-408,4,1,8,"2, 4",2
1-410,4,1,3,"2, 4",1
"K, 1, 2-417",7,1,4,"2, 4",2
2-411,7,"2, 8",1,8,2
2-414,7,"2, 4",1,1,4
2-412,7,"2, 4",1,7,6
2-413,7,"2, 7",1,4,6
3-418,8,3,"3, 8",1,8
3-420,4,7,"3, 8",1,2
3-416,"2, 8","5, 8","3, 7, 8",1,"3, 4"
3-419,8,5,"3, 8",1,5
3-415,8,2,"3, 7",1,7
4-509,1,8,3,"3, 8",1
4-508,2,6,7,"3, 6",1
4-510,6,7,1,"3, 6",1
4-515,6,1,6,"3, 7",1
"3, 4, 5-518",3,8,7,"3, 8",1
5-513,3,"3, 8",1,7,8
5-514,3,"3, 4",4,7,7
5-512,3,"3, 8",5,7,8
5-511,3,"3, 7",4,4,8

================
File: scheduler-backend/tests/integration/test_scheduler.py
================
import pytest
from datetime import datetime, timedelta
from app.scheduler import create_schedule_dev
from app.models import (
    ScheduleRequest,
    ScheduleConstraints,
    TimeSlot,
    WeeklySchedule
)
from tests.utils.generators import (
    ClassGenerator,
    TeacherAvailabilityGenerator,
    TimeSlotGenerator,
    ScheduleRequestGenerator
)
from tests.utils.assertions import assert_valid_schedule

def test_basic_schedule_generation():
    """Test basic end-to-end schedule generation"""
    request = ScheduleRequestGenerator.create_request(
        num_classes=5,
        num_weeks=1
    )
    
    response = create_schedule_dev(request)
    assert_valid_schedule(response, request)
    
    # Verify metadata
    assert response.metadata.solver == "cp-sat-dev"
    assert response.metadata.duration > 0
    assert response.metadata.score > 0

def test_complex_constraints():
    """Test schedule generation with complex interacting constraints"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=14)
    
    # Create classes with various constraints
    classes = []
    
    # Class 1: Required periods and conflicts
    classes.append(ClassGenerator.create_class(
        class_id="complex-1",
        weekly_schedule=WeeklySchedule(
            conflicts=TimeSlotGenerator.create_daily_pattern(1),  # No first periods
            preferredPeriods=[],
            requiredPeriods=[TimeSlot(dayOfWeek=2, period=3)],  # Tuesday third period
            avoidPeriods=[],
            preferenceWeight=1.0,
            avoidanceWeight=1.0
        )
    ))
    
    # Class 2: Strong period preferences
    classes.append(ClassGenerator.create_class(
        class_id="complex-2",
        weekly_schedule=WeeklySchedule(
            conflicts=[],
            preferredPeriods=TimeSlotGenerator.create_daily_pattern(2),  # Prefer second periods
            requiredPeriods=[],
            avoidPeriods=[],
            preferenceWeight=2.0,  # Strong preference
            avoidanceWeight=1.0
        )
    ))
    
    # Class 3: Multiple avoid periods
    classes.append(ClassGenerator.create_class(
        class_id="complex-3",
        weekly_schedule=WeeklySchedule(
            conflicts=[],
            preferredPeriods=[],
            requiredPeriods=[],
            avoidPeriods=TimeSlotGenerator.create_daily_pattern(8),  # Avoid last periods
            preferenceWeight=1.0,
            avoidanceWeight=1.5  # Strong avoidance
        )
    ))
    
    # Create teacher availability with complex patterns
    unavailable_slots = (
        TimeSlotGenerator.create_daily_pattern(4) +  # Fourth period
        TimeSlotGenerator.create_daily_pattern(5)    # Fifth period (lunch)
    )
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=2,
            unavailable_pattern=unavailable_slots
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=2,
            maxClassesPerWeek=5,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    response = create_schedule_dev(request)
    assert_valid_schedule(response, request)

def test_edge_cases():
    """Test schedule generation with edge cases"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    # Edge case 1: Class with many conflicts
    many_conflicts = []
    for day in range(1, 6):  # Monday-Friday
        many_conflicts.extend([
            TimeSlot(dayOfWeek=day, period=p)
            for p in [1, 2, 3, 6, 7, 8]  # Only periods 4-5 available
        ])
    
    # Edge case 2: Class with many required periods
    many_required = [
        TimeSlot(dayOfWeek=1, period=2),  # Monday second
        TimeSlot(dayOfWeek=2, period=3),  # Tuesday third
        TimeSlot(dayOfWeek=3, period=4),  # Wednesday fourth
    ]
    
    classes = [
        # Class with minimal availability
        ClassGenerator.create_class(
            class_id="edge-1",
            weekly_schedule=WeeklySchedule(
                conflicts=many_conflicts,
                preferredPeriods=[],
                requiredPeriods=[],
                avoidPeriods=[],
                preferenceWeight=1.0,
                avoidanceWeight=1.0
            )
        ),
        # Class with multiple required periods
        ClassGenerator.create_class(
            class_id="edge-2",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=[],
                requiredPeriods=many_required,
                avoidPeriods=[],
                preferenceWeight=1.0,
                avoidanceWeight=1.0
            )
        )
    ]
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=2,
            maxClassesPerWeek=5,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    response = create_schedule_dev(request)
    assert_valid_schedule(response, request)

def test_error_handling():
    """Test scheduler error handling with invalid inputs"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    # Test case 1: Overlapping required periods
    overlapping_required = [
        TimeSlot(dayOfWeek=2, period=3),  # Tuesday third period
        TimeSlot(dayOfWeek=2, period=3)   # Same period
    ]
    
    classes = [
        ClassGenerator.create_class(
            class_id="test-1",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=[],
                requiredPeriods=overlapping_required,
                avoidPeriods=[],
                preferenceWeight=1.0,
                avoidanceWeight=1.0
            )
        ),
        ClassGenerator.create_class(
            class_id="test-2",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=[],
                requiredPeriods=overlapping_required,
                avoidPeriods=[],
                preferenceWeight=1.0,
                avoidanceWeight=1.0
            )
        )
    ]
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=2,
            maxClassesPerWeek=5,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Should raise an exception due to impossible constraints
    with pytest.raises(Exception) as exc_info:
        create_schedule_dev(request)
    assert "No solution found" in str(exc_info.value)

def test_optimization_priorities():
    """Test that optimization priorities are respected"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    # Create classes with competing preferences
    classes = [
        # Class with required period (highest priority)
        ClassGenerator.create_class(
            class_id="prio-1",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=[],
                requiredPeriods=[TimeSlot(dayOfWeek=2, period=3)],
                avoidPeriods=[],
                preferenceWeight=1.0,
                avoidanceWeight=1.0
            )
        ),
        # Class with strong preference (medium priority)
        ClassGenerator.create_class(
            class_id="prio-2",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=[TimeSlot(dayOfWeek=2, period=3)],  # Same as required above
                requiredPeriods=[],
                avoidPeriods=[],
                preferenceWeight=2.0,
                avoidanceWeight=1.0
            )
        )
    ]
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=2,
            maxClassesPerWeek=5,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    response = create_schedule_dev(request)
    assert_valid_schedule(response, request)
    
    # Verify that prio-1 got its required period
    prio1_assignment = next(a for a in response.assignments if a.classId == "prio-1")
    assert prio1_assignment.timeSlot.dayOfWeek == 2
    assert prio1_assignment.timeSlot.period == 3

================
File: scheduler-backend/tests/performance/test_benchmarks.py
================
import pytest
import time
import psutil
import os
from datetime import datetime, timedelta
from app.scheduler import create_schedule_dev
from app.models import ScheduleConstraints
from tests.utils.generators import (
    ClassGenerator,
    TeacherAvailabilityGenerator,
    ScheduleRequestGenerator
)
from tests.utils.assertions import assert_valid_schedule

def measure_memory_usage():
    """Get current memory usage in MB"""
    process = psutil.Process(os.getpid())
    return process.memory_info().rss / 1024 / 1024  # Convert bytes to MB

def test_small_dataset_performance():
    """Test performance with a small dataset (5-10 classes)"""
    # Create schedule request with 8 classes
    request = ScheduleRequestGenerator.create_request(
        num_classes=8,
        num_weeks=2,
        constraints=ScheduleConstraints(
            maxClassesPerDay=3,
            maxClassesPerWeek=8,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Measure initial memory
    start_memory = measure_memory_usage()
    
    # Time the schedule generation
    start_time = time.time()
    response = create_schedule_dev(request)
    end_time = time.time()
    
    # Measure final memory
    end_memory = measure_memory_usage()
    
    # Calculate metrics
    duration_ms = int((end_time - start_time) * 1000)
    memory_increase = end_memory - start_memory
    
    # Verify schedule is valid
    assert_valid_schedule(response, request)
    
    # Assert performance meets requirements
    assert duration_ms < 5000, f"Small dataset took too long: {duration_ms}ms"
    assert memory_increase < 100, f"Memory usage too high: {memory_increase}MB increase"
    
    print(f"\nSmall Dataset Performance:")
    print(f"Duration: {duration_ms}ms")
    print(f"Memory Increase: {memory_increase:.2f}MB")

def test_medium_dataset_performance():
    """Test performance with a medium dataset (20-30 classes)"""
    # Create schedule request with 25 classes
    request = ScheduleRequestGenerator.create_request(
        num_classes=25,
        num_weeks=3,
        constraints=ScheduleConstraints(
            maxClassesPerDay=5,
            maxClassesPerWeek=15,
            minPeriodsPerWeek=2,
            maxConsecutiveClasses=2,
            consecutiveClassesRule="soft"
        )
    )
    
    # Measure initial memory
    start_memory = measure_memory_usage()
    
    # Time the schedule generation
    start_time = time.time()
    response = create_schedule_dev(request)
    end_time = time.time()
    
    # Measure final memory
    end_memory = measure_memory_usage()
    
    # Calculate metrics
    duration_ms = int((end_time - start_time) * 1000)
    memory_increase = end_memory - start_memory
    
    # Verify schedule is valid
    assert_valid_schedule(response, request)
    
    # Assert performance meets requirements
    assert duration_ms < 15000, f"Medium dataset took too long: {duration_ms}ms"
    assert memory_increase < 250, f"Memory usage too high: {memory_increase}MB increase"
    
    print(f"\nMedium Dataset Performance:")
    print(f"Duration: {duration_ms}ms")
    print(f"Memory Increase: {memory_increase:.2f}MB")

def test_large_dataset_performance():
    """Test performance with a large dataset (50+ classes)"""
    # Create schedule request with 50 classes
    request = ScheduleRequestGenerator.create_request(
        num_classes=50,
        num_weeks=4,
        constraints=ScheduleConstraints(
            maxClassesPerDay=8,
            maxClassesPerWeek=25,
            minPeriodsPerWeek=3,
            maxConsecutiveClasses=2,
            consecutiveClassesRule="soft"
        )
    )
    
    # Measure initial memory
    start_memory = measure_memory_usage()
    
    # Time the schedule generation
    start_time = time.time()
    response = create_schedule_dev(request)
    end_time = time.time()
    
    # Measure final memory
    end_memory = measure_memory_usage()
    
    # Calculate metrics
    duration_ms = int((end_time - start_time) * 1000)
    memory_increase = end_memory - start_memory
    
    # Verify schedule is valid
    assert_valid_schedule(response, request)
    
    # Assert performance meets requirements
    assert duration_ms < 30000, f"Large dataset took too long: {duration_ms}ms"
    assert memory_increase < 500, f"Memory usage too high: {memory_increase}MB increase"
    
    print(f"\nLarge Dataset Performance:")
    print(f"Duration: {duration_ms}ms")
    print(f"Memory Increase: {memory_increase:.2f}MB")

def test_solver_convergence():
    """Test how quickly the solver converges to a solution with increasing complexity"""
    class_counts = [5, 10, 15, 20, 25]
    convergence_times = []
    
    for num_classes in class_counts:
        request = ScheduleRequestGenerator.create_request(
            num_classes=num_classes,
            num_weeks=2,
            constraints=ScheduleConstraints(
                maxClassesPerDay=5,
                maxClassesPerWeek=15,
                minPeriodsPerWeek=1,
                maxConsecutiveClasses=2,
                consecutiveClassesRule="soft"
            )
        )
        
        # Time the schedule generation
        start_time = time.time()
        response = create_schedule_dev(request)
        duration_ms = int((time.time() - start_time) * 1000)
        
        convergence_times.append(duration_ms)
        
        # Verify schedule is valid
        assert_valid_schedule(response, request)
    
    print("\nSolver Convergence Times:")
    for classes, duration in zip(class_counts, convergence_times):
        print(f"{classes} classes: {duration}ms")
        
    # Check for reasonable scaling
    for i in range(1, len(convergence_times)):
        time_increase = convergence_times[i] / convergence_times[i-1]
        assert time_increase < 5, f"Solver scaling too steep between {class_counts[i-1]} and {class_counts[i]} classes"

def test_memory_scaling():
    """Test how memory usage scales with problem size"""
    class_counts = [5, 10, 15, 20, 25]
    memory_increases = []
    
    for num_classes in class_counts:
        request = ScheduleRequestGenerator.create_request(
            num_classes=num_classes,
            num_weeks=2,
            constraints=ScheduleConstraints(
                maxClassesPerDay=5,
                maxClassesPerWeek=15,
                minPeriodsPerWeek=1,
                maxConsecutiveClasses=2,
                consecutiveClassesRule="soft"
            )
        )
        
        # Measure memory usage
        start_memory = measure_memory_usage()
        response = create_schedule_dev(request)
        memory_increase = measure_memory_usage() - start_memory
        
        memory_increases.append(memory_increase)
        
        # Verify schedule is valid
        assert_valid_schedule(response, request)
    
    print("\nMemory Scaling:")
    for classes, memory in zip(class_counts, memory_increases):
        print(f"{classes} classes: {memory:.2f}MB")
        
    # Check for reasonable scaling
    for i in range(1, len(memory_increases)):
        memory_ratio = memory_increases[i] / memory_increases[i-1]
        assert memory_ratio < 3, f"Memory scaling too steep between {class_counts[i-1]} and {class_counts[i]} classes"

================
File: scheduler-backend/tests/unit/test_constraints.py
================
import pytest
from datetime import datetime, timedelta
from app.scheduler import create_schedule_dev
from app.models import (
    ScheduleRequest,
    ScheduleConstraints,
    TimeSlot,
    WeeklySchedule
)
from tests.utils.generators import (
    ClassGenerator,
    TeacherAvailabilityGenerator,
    TimeSlotGenerator
)
from tests.utils.assertions import (
    assert_valid_assignments,
    assert_no_overlaps,
    assert_respects_conflicts,
    assert_respects_teacher_availability,
    assert_respects_required_periods,
    assert_respects_class_limits,
    assert_respects_consecutive_classes,
    assert_valid_schedule
)

def test_single_assignment():
    """Test that each class is scheduled exactly once"""
    # Create a simple schedule request with multiple classes
    start_date = datetime.now()
    end_date = start_date + timedelta(days=14)
    
    request = ScheduleRequest(
        classes=ClassGenerator.create_multiple_classes(3),
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=2
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=3,
            maxClassesPerWeek=8,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Verify each class is scheduled exactly once
    assert_valid_assignments(response, request)

def test_no_overlaps():
    """Test that no two classes are scheduled at the same time"""
    # Create classes with overlapping preferences to test conflict resolution
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    # Create two classes that prefer the same periods
    preferred_slots = TimeSlotGenerator.create_daily_pattern(2)  # Second period every day
    classes = [
        ClassGenerator.create_class(
            class_id="test-1",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=preferred_slots,
                requiredPeriods=[],
                avoidPeriods=[],
                preferenceWeight=1.5,
                avoidanceWeight=1.0
            )
        ),
        ClassGenerator.create_class(
            class_id="test-2",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=preferred_slots,
                requiredPeriods=[],
                avoidPeriods=[],
                preferenceWeight=1.5,
                avoidanceWeight=1.0
            )
        )
    ]
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=3,
            maxClassesPerWeek=8,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Verify no overlaps
    assert_no_overlaps(response)

def test_respects_conflicts():
    """Test that classes are not scheduled during their conflict periods"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    # Create class with specific conflicts
    conflict_slots = TimeSlotGenerator.create_daily_pattern(1)  # First period every day
    classes = [
        ClassGenerator.create_class(
            class_id="test-1",
            weekly_schedule=WeeklySchedule(
                conflicts=conflict_slots,
                preferredPeriods=[],
                requiredPeriods=[],
                avoidPeriods=[],
                preferenceWeight=1.0,
                avoidanceWeight=1.0
            )
        )
    ]
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=3,
            maxClassesPerWeek=8,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Verify conflicts are respected
    assert_respects_conflicts(response, request)

def test_respects_teacher_availability():
    """Test that classes are not scheduled during teacher unavailable periods"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    # Create specific teacher unavailability pattern
    unavailable_slots = TimeSlotGenerator.create_daily_pattern(4)  # Fourth period every day
    
    request = ScheduleRequest(
        classes=ClassGenerator.create_multiple_classes(2),
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1,
            unavailable_pattern=unavailable_slots
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=3,
            maxClassesPerWeek=8,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Verify teacher availability is respected
    assert_respects_teacher_availability(response, request)

def test_respects_required_periods():
    """Test that classes are scheduled in their required periods"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    # Create class with specific required periods
    required_slots = [TimeSlot(dayOfWeek=2, period=3)]  # Tuesday third period
    classes = [
        ClassGenerator.create_class(
            class_id="test-1",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=[],
                requiredPeriods=required_slots,
                avoidPeriods=[],
                preferenceWeight=1.0,
                avoidanceWeight=1.0
            )
        )
    ]
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=3,
            maxClassesPerWeek=8,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Verify required periods are respected
    assert_respects_required_periods(response, request)

def test_respects_class_limits():
    """Test that daily and weekly class limits are respected"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=14)
    
    request = ScheduleRequest(
        classes=ClassGenerator.create_multiple_classes(10),  # Create many classes
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=2
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=2,    # Strict daily limit
            maxClassesPerWeek=5,   # Strict weekly limit
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Verify class limits are respected
    assert_respects_class_limits(response, request)

def test_respects_consecutive_classes():
    """Test that consecutive class constraints are respected"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    request = ScheduleRequest(
        classes=ClassGenerator.create_multiple_classes(5),
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=4,
            maxClassesPerWeek=8,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,  # No consecutive classes allowed
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Verify consecutive class constraints are respected
    assert_respects_consecutive_classes(response, request)

def test_all_constraints():
    """Test that all constraints are respected simultaneously"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=14)
    
    # Create complex test scenario
    conflict_slots = TimeSlotGenerator.create_daily_pattern(1)  # First period conflicts
    required_slots = [TimeSlot(dayOfWeek=2, period=3)]  # Tuesday third period required
    unavailable_slots = TimeSlotGenerator.create_daily_pattern(4)  # Fourth period unavailable
    
    classes = [
        ClassGenerator.create_class(
            class_id="test-1",
            weekly_schedule=WeeklySchedule(
                conflicts=conflict_slots,
                preferredPeriods=[],
                requiredPeriods=required_slots,
                avoidPeriods=[],
                preferenceWeight=1.0,
                avoidanceWeight=1.0
            )
        ),
        ClassGenerator.create_class(
            class_id="test-2",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=[],
                requiredPeriods=[],
                avoidPeriods=[],
                preferenceWeight=1.0,
                avoidanceWeight=1.0
            )
        )
    ]
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=2,
            unavailable_pattern=unavailable_slots
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=2,
            maxClassesPerWeek=5,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Verify all constraints
    assert_valid_schedule(response, request)

================
File: scheduler-backend/tests/unit/test_distribution.py
================
import pytest
from datetime import datetime, timedelta
from statistics import variance
from collections import defaultdict
from app.scheduler import create_schedule_dev
from app.models import (
    ScheduleRequest,
    ScheduleConstraints,
    TimeSlot,
    WeeklySchedule
)
from tests.utils.generators import (
    ClassGenerator,
    TeacherAvailabilityGenerator,
    TimeSlotGenerator,
    ScheduleRequestGenerator
)
from tests.utils.assertions import assert_valid_schedule

def calculate_weekly_variance(response, request) -> float:
    """Calculate variance in class distribution across weeks"""
    start_date = datetime.strptime(request.startDate, "%Y-%m-%d")
    classes_per_week = defaultdict(int)
    
    for assignment in response.assignments:
        date = datetime.strptime(assignment.date.split('T')[0], "%Y-%m-%d")
        week_num = (date - start_date).days // 7
        classes_per_week[week_num] += 1
    
    if not classes_per_week:
        return 0.0
    counts = list(classes_per_week.values())
    return variance(counts) if len(counts) > 1 else 0.0

def calculate_daily_spread(response) -> dict:
    """Calculate how well classes are spread across periods each day"""
    classes_per_period = defaultdict(lambda: defaultdict(int))
    
    for assignment in response.assignments:
        date = assignment.date.split('T')[0]
        period = assignment.timeSlot.period
        classes_per_period[date][period] += 1
    
    spreads = {}
    for date, periods in classes_per_period.items():
        counts = [periods[p] for p in range(1, 9)]  # periods 1-8
        if len(counts) > 1:
            spreads[date] = variance(counts)
        else:
            spreads[date] = 0.0
    
    return spreads

def test_weekly_distribution():
    """Test that classes are distributed evenly across weeks"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=21)  # 3 weeks
    
    request = ScheduleRequest(
        classes=ClassGenerator.create_multiple_classes(15),  # Multiple classes to distribute
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=3
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=3,
            maxClassesPerWeek=5,  # Force distribution across weeks
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Calculate weekly variance
    weekly_variance = calculate_weekly_variance(response, request)
    
    # Assert low variance (good distribution)
    assert weekly_variance < 2.0, f"Weekly distribution variance too high: {weekly_variance}"

def test_daily_period_spread():
    """Test that classes are well-distributed across periods within each day"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    request = ScheduleRequest(
        classes=ClassGenerator.create_multiple_classes(8),  # Enough classes for multiple per day
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=4,
            maxClassesPerWeek=8,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Calculate daily spread
    daily_spreads = calculate_daily_spread(response)
    
    # Assert good distribution within each day
    for date, spread in daily_spreads.items():
        assert spread < 1.5, f"Poor period distribution on {date}, variance: {spread}"

def test_preference_satisfaction():
    """Test that preferred periods are prioritized when possible"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    # Create class with specific preferences
    preferred_slots = TimeSlotGenerator.create_daily_pattern(2)  # Second period every day
    classes = [
        ClassGenerator.create_class(
            class_id="test-1",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=preferred_slots,
                requiredPeriods=[],
                avoidPeriods=[],
                preferenceWeight=2.0,  # Strong preference
                avoidanceWeight=1.0
            )
        )
    ]
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=3,
            maxClassesPerWeek=8,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Check if assigned to a preferred period
    assignment = response.assignments[0]  # Only one class
    weekday = datetime.strptime(assignment.date, "%Y-%m-%d").weekday() + 1
    is_preferred = any(
        ps.dayOfWeek == weekday and ps.period == assignment.timeSlot.period
        for ps in preferred_slots
    )
    
    assert is_preferred, "Class not scheduled in preferred period"

def test_avoidance_respect():
    """Test that avoided periods are respected when possible"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=7)
    
    # Create class with specific avoid periods
    avoid_slots = TimeSlotGenerator.create_daily_pattern(8)  # Last period every day
    classes = [
        ClassGenerator.create_class(
            class_id="test-1",
            weekly_schedule=WeeklySchedule(
                conflicts=[],
                preferredPeriods=[],
                requiredPeriods=[],
                avoidPeriods=avoid_slots,
                preferenceWeight=1.0,
                avoidanceWeight=2.0  # Strong avoidance
            )
        )
    ]
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=1
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=3,
            maxClassesPerWeek=8,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Check if assigned to an avoided period
    assignment = response.assignments[0]  # Only one class
    weekday = datetime.strptime(assignment.date, "%Y-%m-%d").weekday() + 1
    is_avoided = any(
        aps.dayOfWeek == weekday and aps.period == assignment.timeSlot.period
        for aps in avoid_slots
    )
    
    assert not is_avoided, "Class scheduled in avoided period"

def test_distribution_with_constraints():
    """Test that distribution optimization works with other constraints"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=14)
    
    # Create complex scenario with multiple constraints
    conflict_slots = TimeSlotGenerator.create_daily_pattern(1)  # First period conflicts
    required_slots = [TimeSlot(dayOfWeek=2, period=3)]  # Tuesday third period required
    preferred_slots = TimeSlotGenerator.create_daily_pattern(2)  # Second period preferred
    avoid_slots = TimeSlotGenerator.create_daily_pattern(8)  # Last period avoided
    
    classes = [
        ClassGenerator.create_class(
            class_id=f"test-{i}",
            weekly_schedule=WeeklySchedule(
                conflicts=conflict_slots if i == 0 else [],
                preferredPeriods=preferred_slots if i == 1 else [],
                requiredPeriods=required_slots if i == 2 else [],
                avoidPeriods=avoid_slots if i == 3 else [],
                preferenceWeight=1.5,
                avoidanceWeight=1.2
            )
        )
        for i in range(4)
    ]
    
    request = ScheduleRequest(
        classes=classes,
        teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
            start_date=start_date,
            weeks=2
        ),
        startDate=start_date.strftime("%Y-%m-%d"),
        endDate=end_date.strftime("%Y-%m-%d"),
        constraints=ScheduleConstraints(
            maxClassesPerDay=2,
            maxClassesPerWeek=4,
            minPeriodsPerWeek=1,
            maxConsecutiveClasses=1,
            consecutiveClassesRule="hard"
        )
    )
    
    # Generate schedule
    response = create_schedule_dev(request)
    
    # Verify distribution metrics
    weekly_variance = calculate_weekly_variance(response, request)
    daily_spreads = calculate_daily_spread(response)
    
    # Assert good distribution while respecting constraints
    assert weekly_variance < 2.0, f"Weekly distribution variance too high: {weekly_variance}"
    for date, spread in daily_spreads.items():
        assert spread < 1.5, f"Poor period distribution on {date}, variance: {spread}"

================
File: scheduler-backend/tests/utils/assertions.py
================
from typing import List, Dict, Set
from datetime import datetime
from dateutil import parser
from collections import defaultdict

from app.models import (
    ScheduleRequest,
    ScheduleResponse,
    ScheduleAssignment,
    TimeSlot
)

def assert_valid_assignments(response: ScheduleResponse, request: ScheduleRequest):
    """Verify that all assignments are valid according to the schedule request"""
    
    # Check that each class is scheduled exactly once
    class_assignments = defaultdict(int)
    for assignment in response.assignments:
        class_assignments[assignment.classId] += 1
    
    for class_obj in request.classes:
        assert class_assignments[class_obj.id] == 1, \
            f"Class {class_obj.id} has {class_assignments[class_obj.id]} assignments, expected 1"

def assert_no_overlaps(response: ScheduleResponse):
    """Verify that no two classes are scheduled at the same time"""
    
    # Group assignments by date and period
    time_slots: Dict[str, Dict[int, List[str]]] = defaultdict(lambda: defaultdict(list))
    
    for assignment in response.assignments:
        date = assignment.date.split('T')[0]  # Remove time part if present
        period = assignment.timeSlot.period
        time_slots[date][period].append(assignment.classId)
        
        # Check for overlaps
        assert len(time_slots[date][period]) == 1, \
            f"Multiple classes scheduled on {date} period {period}: {time_slots[date][period]}"

def assert_respects_conflicts(response: ScheduleResponse, request: ScheduleRequest):
    """Verify that no classes are scheduled during their conflict periods"""
    
    for assignment in response.assignments:
        # Find the corresponding class
        class_obj = next(c for c in request.classes if c.id == assignment.classId)
        weekday = parser.parse(assignment.date).weekday() + 1  # 1-5 (Mon-Fri)
        
        # Check against conflicts
        for conflict in class_obj.weeklySchedule.conflicts:
            assert not (
                conflict.dayOfWeek == weekday and 
                conflict.period == assignment.timeSlot.period
            ), f"Class {class_obj.id} scheduled during conflict period: day {weekday} period {assignment.timeSlot.period}"

def assert_respects_teacher_availability(response: ScheduleResponse, request: ScheduleRequest):
    """Verify that no classes are scheduled during teacher unavailable periods"""
    
    # Create lookup for teacher unavailability
    unavailable_slots: Dict[str, Set[TimeSlot]] = defaultdict(set)
    for availability in request.teacherAvailability:
        date = availability.date.split('T')[0]
        for slot in availability.unavailableSlots:
            unavailable_slots[date].add(slot)
    
    # Check each assignment
    for assignment in response.assignments:
        date = assignment.date.split('T')[0]
        if date in unavailable_slots:
            for unavailable in unavailable_slots[date]:
                assert not (
                    assignment.timeSlot.dayOfWeek == unavailable.dayOfWeek and
                    assignment.timeSlot.period == unavailable.period
                ), f"Class scheduled during teacher unavailable period on {date}"

def assert_respects_required_periods(response: ScheduleResponse, request: ScheduleRequest):
    """Verify that classes with required periods are scheduled in one of them"""
    
    for assignment in response.assignments:
        # Find the corresponding class
        class_obj = next(c for c in request.classes if c.id == assignment.classId)
        
        # Skip if no required periods
        if not class_obj.weeklySchedule.requiredPeriods:
            continue
            
        weekday = parser.parse(assignment.date).weekday() + 1
        period = assignment.timeSlot.period
        
        # Verify scheduled in a required period
        is_required = any(
            rp.dayOfWeek == weekday and rp.period == period
            for rp in class_obj.weeklySchedule.requiredPeriods
        )
        
        assert is_required, \
            f"Class {class_obj.id} not scheduled in a required period"

def assert_respects_class_limits(response: ScheduleResponse, request: ScheduleRequest):
    """Verify that daily and weekly class limits are respected"""
    
    # Group assignments by date
    by_date = defaultdict(list)
    by_week = defaultdict(list)
    start_date = parser.parse(request.startDate)
    
    for assignment in response.assignments:
        date = parser.parse(assignment.date)
        by_date[date.date()].append(assignment)
        
        # Calculate week number
        week_num = (date - start_date).days // 7
        by_week[week_num].append(assignment)
    
    # Check daily limits
    for date, assignments in by_date.items():
        assert len(assignments) <= request.constraints.maxClassesPerDay, \
            f"Too many classes ({len(assignments)}) scheduled on {date}"
    
    # Check weekly limits
    for week, assignments in by_week.items():
        assert request.constraints.minPeriodsPerWeek <= len(assignments) <= request.constraints.maxClassesPerWeek, \
            f"Week {week} has {len(assignments)} classes, outside limits [{request.constraints.minPeriodsPerWeek}, {request.constraints.maxClassesPerWeek}]"

def assert_respects_consecutive_classes(response: ScheduleResponse, request: ScheduleRequest):
    """Verify that consecutive class constraints are respected"""
    
    if request.constraints.consecutiveClassesRule != "hard":
        return  # Skip for soft constraints
    
    # Group assignments by date
    by_date = defaultdict(list)
    for assignment in response.assignments:
        date = parser.parse(assignment.date).date()
        by_date[date].append(assignment)
    
    # Check consecutive classes
    for date, assignments in by_date.items():
        # Sort by period
        assignments.sort(key=lambda x: x.timeSlot.period)
        
        # Check for consecutive periods
        consecutive_count = 1
        for i in range(1, len(assignments)):
            if assignments[i].timeSlot.period == assignments[i-1].timeSlot.period + 1:
                consecutive_count += 1
                assert consecutive_count <= request.constraints.maxConsecutiveClasses, \
                    f"Too many consecutive classes ({consecutive_count}) on {date}"
            else:
                consecutive_count = 1

def assert_valid_schedule(response: ScheduleResponse, request: ScheduleRequest):
    """Run all schedule validation checks"""
    assert_valid_assignments(response, request)
    assert_no_overlaps(response)
    assert_respects_conflicts(response, request)
    assert_respects_teacher_availability(response, request)
    assert_respects_required_periods(response, request)
    assert_respects_class_limits(response, request)
    assert_respects_consecutive_classes(response, request)

================
File: scheduler-backend/tests/utils/generators.py
================
from datetime import datetime, timedelta
from typing import List, Optional
from app.models import (
    Class,
    TimeSlot,
    WeeklySchedule,
    TeacherAvailability,
    ScheduleConstraints,
    ScheduleRequest
)

class TimeSlotGenerator:
    @staticmethod
    def create_sequential_slots(count: int, start_day: int = 1, start_period: int = 1) -> List[TimeSlot]:
        """Create a sequence of time slots"""
        slots = []
        day = start_day
        period = start_period
        
        for _ in range(count):
            slots.append(TimeSlot(dayOfWeek=day, period=period))
            period += 1
            if period > 8:  # Move to next day if we exceed 8 periods
                period = 1
                day += 1
            if day > 5:  # Reset to Monday if we exceed Friday
                day = 1
        
        return slots

    @staticmethod
    def create_daily_pattern(period: int, days: Optional[List[int]] = None) -> List[TimeSlot]:
        """Create time slots for specified period across multiple days"""
        if days is None:
            days = list(range(1, 6))  # Monday through Friday
        return [TimeSlot(dayOfWeek=day, period=period) for day in days]

class WeeklyScheduleGenerator:
    @staticmethod
    def create_schedule(
        num_conflicts: int = 1,
        num_preferred: int = 1,
        num_required: int = 1,
        num_avoid: int = 1,
        preference_weight: float = 1.5,
        avoidance_weight: float = 1.2
    ) -> WeeklySchedule:
        """Create a weekly schedule with specified numbers of each type of period"""
        all_slots = TimeSlotGenerator.create_sequential_slots(20)  # Large pool to select from
        
        return WeeklySchedule(
            conflicts=all_slots[:num_conflicts],
            preferredPeriods=all_slots[num_conflicts:num_conflicts + num_preferred],
            requiredPeriods=all_slots[num_conflicts + num_preferred:num_conflicts + num_preferred + num_required],
            avoidPeriods=all_slots[num_conflicts + num_preferred + num_required:num_conflicts + num_preferred + num_required + num_avoid],
            preferenceWeight=preference_weight,
            avoidanceWeight=avoidance_weight
        )

class ClassGenerator:
    @staticmethod
    def create_class(
        class_id: Optional[str] = None,
        grade: Optional[str] = None,
        weekly_schedule: Optional[WeeklySchedule] = None
    ) -> Class:
        """Create a class with specified or default parameters"""
        if class_id is None:
            class_id = f"test-{datetime.now().strftime('%H%M%S')}"
        if grade is None:
            grade = "1"
        if weekly_schedule is None:
            weekly_schedule = WeeklyScheduleGenerator.create_schedule()
            
        return Class(
            id=class_id,
            name=f"Test Class {class_id}",
            grade=grade,
            weeklySchedule=weekly_schedule
        )

    @staticmethod
    def create_multiple_classes(
        count: int,
        grade_prefix: str = "",
        with_conflicts: bool = True
    ) -> List[Class]:
        """Create multiple classes with optional grade prefix and conflicts"""
        classes = []
        for i in range(count):
            class_id = f"{grade_prefix}{i+1}"
            weekly_schedule = WeeklyScheduleGenerator.create_schedule(
                num_conflicts=1 if with_conflicts else 0
            )
            classes.append(ClassGenerator.create_class(
                class_id=class_id,
                grade=grade_prefix if grade_prefix else str(i+1),
                weekly_schedule=weekly_schedule
            ))
        return classes

class TeacherAvailabilityGenerator:
    @staticmethod
    def create_availability(
        date: Optional[str] = None,
        num_unavailable: int = 1,
        num_preferred: int = 1,
        num_avoid: int = 1
    ) -> TeacherAvailability:
        """Create teacher availability for a specific date"""
        if date is None:
            date = datetime.now().strftime("%Y-%m-%d")
            
        all_slots = TimeSlotGenerator.create_sequential_slots(20)
        
        return TeacherAvailability(
            date=date,
            unavailableSlots=all_slots[:num_unavailable],
            preferredSlots=all_slots[num_unavailable:num_unavailable + num_preferred],
            avoidSlots=all_slots[num_unavailable + num_preferred:num_unavailable + num_preferred + num_avoid]
        )

    @staticmethod
    def create_weekly_availability(
        start_date: datetime,
        weeks: int = 1,
        unavailable_pattern: Optional[List[TimeSlot]] = None
    ) -> List[TeacherAvailability]:
        """Create teacher availability for multiple weeks"""
        if unavailable_pattern is None:
            # Default to lunch periods (period 5) every day
            unavailable_pattern = TimeSlotGenerator.create_daily_pattern(5)
            
        availability = []
        current_date = start_date
        
        for _ in range(weeks * 5):  # 5 school days per week
            if current_date.weekday() < 5:  # Only add for weekdays
                availability.append(TeacherAvailabilityGenerator.create_availability(
                    date=current_date.strftime("%Y-%m-%d"),
                    num_unavailable=len(unavailable_pattern)
                ))
            current_date += timedelta(days=1)
            
        return availability

class ScheduleRequestGenerator:
    @staticmethod
    def create_request(
        num_classes: int = 1,
        num_weeks: int = 2,
        constraints: Optional[ScheduleConstraints] = None,
        start_date: Optional[datetime] = None
    ) -> ScheduleRequest:
        """Create a complete schedule request"""
        if start_date is None:
            start_date = datetime.now()
        if constraints is None:
            constraints = ScheduleConstraints(
                maxClassesPerDay=3,
                maxClassesPerWeek=8,
                minPeriodsPerWeek=1,
                maxConsecutiveClasses=1,
                consecutiveClassesRule="hard"
            )
            
        end_date = start_date + timedelta(weeks=num_weeks)
        
        return ScheduleRequest(
            classes=ClassGenerator.create_multiple_classes(num_classes),
            teacherAvailability=TeacherAvailabilityGenerator.create_weekly_availability(
                start_date=start_date,
                weeks=num_weeks
            ),
            startDate=start_date.strftime("%Y-%m-%d"),
            endDate=end_date.strftime("%Y-%m-%d"),
            constraints=constraints
        )

================
File: scheduler-backend/tests/conftest.py
================
import pytest
from datetime import datetime, timedelta
from typing import List
from app.models import (
    ScheduleRequest,
    Class,
    TimeSlot,
    WeeklySchedule,
    TeacherAvailability,
    ScheduleConstraints
)

@pytest.fixture
def base_time_slots() -> List[TimeSlot]:
    """Basic time slots for testing"""
    return [
        TimeSlot(dayOfWeek=1, period=1),  # Monday first period
        TimeSlot(dayOfWeek=2, period=2),  # Tuesday second period
        TimeSlot(dayOfWeek=3, period=3),  # Wednesday third period
        TimeSlot(dayOfWeek=4, period=4),  # Thursday fourth period
        TimeSlot(dayOfWeek=5, period=5),  # Friday fifth period
    ]

@pytest.fixture
def base_weekly_schedule(base_time_slots) -> WeeklySchedule:
    """Basic weekly schedule for testing"""
    return WeeklySchedule(
        conflicts=[base_time_slots[0]],  # Monday first period conflict
        preferredPeriods=[base_time_slots[1]],  # Tuesday second period preferred
        requiredPeriods=[base_time_slots[2]],  # Wednesday third period required
        avoidPeriods=[base_time_slots[4]],  # Friday fifth period avoid
        preferenceWeight=1.5,
        avoidanceWeight=1.2
    )

@pytest.fixture
def base_class(base_weekly_schedule) -> Class:
    """Basic class for testing"""
    return Class(
        id="test-101",
        name="Test Class 101",
        grade="1",
        weeklySchedule=base_weekly_schedule
    )

@pytest.fixture
def base_teacher_availability(base_time_slots) -> TeacherAvailability:
    """Basic teacher availability for testing"""
    return TeacherAvailability(
        date=datetime.now().strftime("%Y-%m-%d"),
        unavailableSlots=[base_time_slots[0]],  # Monday first period unavailable
        preferredSlots=[base_time_slots[1]],    # Tuesday second period preferred
        avoidSlots=[base_time_slots[4]]         # Friday fifth period avoid
    )

@pytest.fixture
def base_schedule_constraints() -> ScheduleConstraints:
    """Basic schedule constraints for testing"""
    return ScheduleConstraints(
        maxClassesPerDay=3,
        maxClassesPerWeek=8,
        minPeriodsPerWeek=1,
        maxConsecutiveClasses=1,
        consecutiveClassesRule="hard"
    )

@pytest.fixture
def date_range():
    """Get a standard date range for testing (2 weeks)"""
    start_date = datetime.now()
    end_date = start_date + timedelta(days=14)
    return {
        "start": start_date.strftime("%Y-%m-%d"),
        "end": end_date.strftime("%Y-%m-%d")
    }

@pytest.fixture
def base_schedule_request(
    base_class,
    base_teacher_availability,
    base_schedule_constraints,
    date_range
) -> ScheduleRequest:
    """Basic schedule request for testing"""
    return ScheduleRequest(
        classes=[base_class],
        teacherAvailability=[base_teacher_availability],
        startDate=date_range["start"],
        endDate=date_range["end"],
        constraints=base_schedule_constraints
    )

================
File: scheduler-backend/tests/README.md
================
# Scheduler Backend Testing Infrastructure

## Overview

This testing infrastructure provides comprehensive test coverage for the scheduler backend, including:
- Core constraint validation
- Distribution optimization verification
- Performance benchmarking
- Integration testing

## Directory Structure

```
tests/
â”œâ”€â”€ conftest.py           # Shared pytest fixtures
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ generators.py     # Test data generation utilities
â”‚   â”œâ”€â”€ assertions.py     # Custom test assertions
â”‚   â””â”€â”€ fixtures.py       # Common test fixtures
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ test_constraints.py   # Core constraint tests
â”‚   â”œâ”€â”€ test_distribution.py  # Distribution tests
â”‚   â””â”€â”€ test_optimization.py  # Optimization tests
â”œâ”€â”€ integration/
â”‚   â””â”€â”€ test_scheduler.py     # End-to-end tests
â””â”€â”€ performance/
    â””â”€â”€ test_benchmarks.py    # Performance tests
```

## Test Categories

### Unit Tests

1. Constraint Tests (`test_constraints.py`)
   - Single assignment validation
   - Overlap prevention
   - Required period satisfaction
   - Teacher availability respect
   - Class limit enforcement
   - Consecutive class handling

2. Distribution Tests (`test_distribution.py`)
   - Weekly variance calculations
   - Period spread metrics
   - Teacher workload balance
   - Multi-objective weights

### Integration Tests (`test_scheduler.py`)
- End-to-end schedule generation
- Complex constraint interactions
- Edge cases
- Error handling
- Optimization priority verification

### Performance Tests (`test_benchmarks.py`)
- Small dataset performance (5-10 classes)
- Medium dataset performance (20-30 classes)
- Large dataset performance (50+ classes)
- Solver convergence analysis
- Memory usage tracking

## Running Tests

### Prerequisites
- Python 3.11.* (ortools requires Python 3.11, newer versions not supported)
- pytest
- psutil (for performance tests)

### Installation
```bash
# Create virtual environment with Python 3.11
python3.11 -m venv venv
source venv/bin/activate  # On Unix/macOS
# or
.\venv\Scripts\activate  # On Windows

# Install dependencies
pip install -r requirements.txt
```

### Running All Tests
```bash
pytest tests/
```

### Running Specific Test Categories
```bash
# Run unit tests only
pytest tests/unit/

# Run integration tests only
pytest tests/integration/

# Run performance tests only
pytest tests/performance/
```

### Running Individual Test Files
```bash
# Run constraint tests
pytest tests/unit/test_constraints.py

# Run distribution tests
pytest tests/unit/test_distribution.py

# Run integration tests
pytest tests/integration/test_scheduler.py

# Run performance tests
pytest tests/performance/test_benchmarks.py
```

### Test Options
```bash
# Run tests with detailed output
pytest -v

# Run tests and show print statements
pytest -s

# Run a specific test function
pytest tests/unit/test_constraints.py::test_single_assignment

# Run tests matching a pattern
pytest -k "test_daily"
```

## Test Utilities

### Data Generators (`generators.py`)
- `TimeSlotGenerator`: Create time slot patterns
- `WeeklyScheduleGenerator`: Generate weekly schedules
- `ClassGenerator`: Create test classes
- `TeacherAvailabilityGenerator`: Generate availability patterns
- `ScheduleRequestGenerator`: Create complete schedule requests

### Assertions (`assertions.py`)
- `assert_valid_assignments`: Verify assignment completeness
- `assert_no_overlaps`: Check for scheduling conflicts
- `assert_respects_conflicts`: Validate conflict handling
- `assert_respects_teacher_availability`: Check availability constraints
- `assert_respects_required_periods`: Verify required period satisfaction
- `assert_respects_class_limits`: Validate class limits
- `assert_respects_consecutive_classes`: Check consecutive class rules
- `assert_valid_schedule`: Comprehensive schedule validation

## Performance Benchmarks

The performance tests include configurable thresholds:
- Small dataset: < 5 seconds, < 100MB memory
- Medium dataset: < 15 seconds, < 250MB memory
- Large dataset: < 30 seconds, < 500MB memory

Memory and timing metrics are logged for analysis.

## Adding New Tests

1. Choose the appropriate category (unit/integration/performance)
2. Create test file in the corresponding directory
3. Use provided utilities from `utils/`
4. Follow existing patterns for consistency
5. Include docstrings and comments
6. Verify with existing test suite

## Best Practices

1. Use generators for test data creation
2. Leverage shared fixtures from `conftest.py`
3. Include clear test descriptions
4. Test edge cases and error conditions
5. Keep performance tests realistic
6. Use appropriate assertions
7. Follow naming conventions

================
File: scheduler-backend/.gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Test artifacts
.pytest_cache/
.coverage
coverage_report/
htmlcov/
.tox/
.nox/
.coverage.*
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Virtual Environment
venv/
ENV/
env/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# Distribution
*.log
logs/
*.pot
*.pyc
local_settings.py
db.sqlite3
db.sqlite3-journal

# Performance test artifacts
prof/
*.prof
*.stats
*.dat

# Environment variables
.env
.env.local
.env.*.local

# Operating System
.DS_Store
Thumbs.db

================
File: scheduler-backend/Dockerfile
================
# Use Python 3.11 slim image
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Copy requirements first to leverage Docker cache
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY app/ app/

# Environment variables
ENV PORT=3001

# Command to run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "3001"]

================
File: scheduler-backend/pytest.ini
================
[pytest]
# Test discovery and collection
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*

# Test execution
addopts =
    # Show detailed test progress
    -v
    # Show local variables in tracebacks
    --showlocals
    # Generate coverage reports
    --cov=app
    --cov-report=term-missing
    --cov-report=html:coverage_report
    # Run tests in parallel
    -n auto
    # Exit on first failure
    --maxfail=1

# Logging configuration
log_cli = true
log_cli_level = INFO
log_cli_format = %(asctime)s [%(levelname)8s] %(message)s (%(filename)s:%(lineno)s)
log_cli_date_format = %Y-%m-%d %H:%M:%S

# Test categories markers
markers =
    unit: Unit tests
    integration: Integration tests
    performance: Performance and benchmarking tests
    constraints: Constraint validation tests
    distribution: Distribution optimization tests
    slow: Tests that take longer to run

# Environment variables for tests
env =
    PYTHONPATH=.
    TESTING=true

# Disable warnings that aren't relevant for testing
filterwarnings =
    ignore::DeprecationWarning
    ignore::UserWarning

# Configure test timeouts
timeout = 300

# Test database configuration (if needed)
# mongodb_fixture_dir = tests/fixtures/mongodb
# mysql_fixture_dir = tests/fixtures/mysql

# Custom test settings
minversion = 6.0
required_plugins = 
    pytest-cov
    pytest-xdist
    pytest-timeout

================
File: scheduler-backend/README.md
================
# Scheduler Backend

## Requirements

- Python 3.11 (required for OR-Tools compatibility)
- Homebrew (recommended for Python installation on macOS)

## Setup Instructions

1. Install Python 3.11 using Homebrew:
```bash
brew install python@3.11
```

2. Create and activate a virtual environment:
```bash
# Create virtual environment using Python 3.11
/opt/homebrew/bin/python3.11 -m venv venv

# Activate virtual environment
source venv/bin/activate
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

## Development

Always ensure you're using the virtual environment when running the scheduler:

```bash
# Activate virtual environment (if not already activated)
source venv/bin/activate

# Run tests
python -m app.test_class_limits

# Run server
uvicorn app.main:app --reload
```

## Common Issues

1. OR-Tools Installation Fails:
   - Make sure you're using Python 3.11
   - Check your Python version: `python --version`
   - If using wrong version, deactivate and recreate venv with Python 3.11

2. Module Not Found Errors:
   - Ensure virtual environment is activated
   - Verify all dependencies are installed: `pip list`
   - If needed, reinstall dependencies: `pip install -r requirements.txt`

================
File: scheduler-backend/requirements.txt
================
# Python version requirement
# Python == 3.11.* (ortools requires Python 3.11, newer versions not supported)

# Core dependencies
fastapi>=0.68.0
uvicorn>=0.15.0
pydantic>=1.8.0
python-dateutil>=2.8.2
ortools>=9.3.10497

# Testing dependencies
pytest>=7.0.0
pytest-cov>=3.0.0  # For coverage reporting
pytest-xdist>=2.5.0  # For parallel test execution
psutil>=5.8.0  # For performance monitoring
freezegun>=1.2.0  # For date/time mocking in tests

# Development dependencies
black>=22.3.0  # Code formatting
isort>=5.10.1  # Import sorting
flake8>=4.0.1  # Linting
mypy>=0.950  # Type checking

================
File: src/components/Calendar.tsx
================
import React from 'react';
import { useScheduleStore } from '../store/scheduleStore';
import { ChevronLeft, ChevronRight, Calendar as CalendarIcon } from 'lucide-react';
import { format, addWeeks, subWeeks, startOfWeek, eachDayOfInterval, endOfWeek, isWithinInterval, startOfDay } from 'date-fns';

const PERIODS = Array.from({ length: 8 }, (_, i) => i + 1);

export const Calendar: React.FC = () => {
  const { assignments, constraints } = useScheduleStore();
  const [currentWeek, setCurrentWeek] = React.useState(() => 
    new Date(constraints.startDate)
  );

  // Calculate the date range for the schedule, using startOfDay to ignore time
  const scheduleInterval = {
    start: startOfDay(new Date(constraints.startDate)),
    end: startOfDay(new Date(constraints.endDate))
  };

  // Get the dates for the current week (Mon-Fri)
  const weekDates = React.useMemo(() => {
    const start = startOfWeek(currentWeek, { weekStartsOn: 1 }); // Start on Monday
    const end = endOfWeek(start, { weekStartsOn: 1 });
    return eachDayOfInterval({ start, end }).slice(0, 5); // Only Mon-Fri
  }, [currentWeek]);

  const getAssignments = (date: Date, period: number) => {
    return assignments.filter(a => {
      const assignmentDate = new Date(a.date);
      return startOfDay(assignmentDate).getTime() === startOfDay(date).getTime() && 
             a.timeSlot.period === period;
    });
  };

  const navigateWeek = (direction: 'prev' | 'next') => {
    setCurrentWeek(current => {
      const newDate = direction === 'prev' 
        ? subWeeks(current, 1) 
        : addWeeks(current, 1);
      
      // Ensure we stay within the schedule range
      if (!isWithinInterval(startOfDay(newDate), scheduleInterval)) {
        return current;
      }
      return newDate;
    });
  };

  const isDateInRange = (date: Date) => {
    return isWithinInterval(startOfDay(date), scheduleInterval);
  };

  return (
    <div className="overflow-x-auto">
      <div className="bg-white p-6 rounded-lg shadow-md">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-semibold flex items-center gap-2">
            <CalendarIcon className="text-blue-500" />
            Gym Class Schedule
          </h2>
          <div className="flex items-center gap-4">
            <button
              onClick={() => navigateWeek('prev')}
              disabled={!isDateInRange(subWeeks(currentWeek, 1))}
              className="p-2 rounded-full hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <ChevronLeft size={20} />
            </button>
            <span className="font-medium">
              Week of {format(weekDates[0], 'MMM d, yyyy')}
            </span>
            <button
              onClick={() => navigateWeek('next')}
              disabled={!isDateInRange(addWeeks(currentWeek, 1))}
              className="p-2 rounded-full hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <ChevronRight size={20} />
            </button>
          </div>
        </div>

        <div className="overflow-x-auto">
          <table className="min-w-full border border-gray-200">
            <thead>
              <tr>
                <th className="border p-2">Period</th>
                {weekDates.map(date => (
                  <th key={date.toISOString()} className="border p-2">
                    <div>{format(date, 'EEEE')}</div>
                    <div className="text-sm text-gray-500">
                      {format(date, 'MMM d')}
                    </div>
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {PERIODS.map(period => (
                <tr key={period}>
                  <td className="border p-2 font-medium">{period}</td>
                  {weekDates.map(date => {
                    const dateAssignments = getAssignments(date, period);
                    const isInScheduleRange = isDateInRange(date);
                    return (
                      <td
                        key={date.toISOString()}
                        className={`border p-2 ${!isInScheduleRange ? 'bg-gray-50' : ''}`}
                      >
                        {isInScheduleRange && dateAssignments.map(assignment => (
                          <div 
                            key={`${assignment.date}-${assignment.timeSlot.period}-${assignment.name}`} 
                            className="p-2 bg-blue-50 rounded"
                          >
                            <div className="font-medium">
                              {assignment.name}
                            </div>
                          </div>
                        ))}
                      </td>
                    );
                  })}
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        <div className="mt-4 text-sm text-gray-500">
          Schedule period: {format(scheduleInterval.start, 'MMM d, yyyy')} - {format(scheduleInterval.end, 'MMM d, yyyy')}
        </div>
      </div>
    </div>
  );
};

================
File: src/components/ClassEditor.tsx
================
import React from 'react';
import { PlusCircle, Trash2, Save, Clock } from 'lucide-react';
import { useScheduleStore } from '../store/scheduleStore';
import type { Class, TimeSlot } from '../types';

const PERIODS = Array.from({ length: 8 }, (_, i) => i + 1);
const DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
const GRADES = ['Pre-K', 'K', '1', '2', '3', '4', '5', 'multiple'];

type CellState = 'blank' | 'conflict' | 'preferred' | 'required' | 'avoid';

export const ClassEditor: React.FC = () => {
  const { classes, setClasses } = useScheduleStore();
  const [selectedClassId, setSelectedClassId] = React.useState<string>('');
  const [editedClass, setEditedClass] = React.useState<Class | null>(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = React.useState(false);
  const [selectedGrade, setSelectedGrade] = React.useState<string>('Pre-K');
  const [gradeLunchPeriod, setGradeLunchPeriod] = React.useState<number>(0);

  React.useEffect(() => {
    if (classes.length > 0 && !selectedClassId) {
      setSelectedClassId(classes[0].id);
    }
  }, [classes]);

  React.useEffect(() => {
    const classToEdit = classes.find(c => c.id === selectedClassId);
    if (classToEdit) {
      setEditedClass({ ...classToEdit });
    } else {
      setEditedClass(null);
    }
    setHasUnsavedChanges(false);
  }, [selectedClassId, classes]);

  const addClass = () => {
    const newClass: Class = {
      id: `class-${Date.now()}`,
      name: '',
      grade: 'Pre-K',
      weeklySchedule: {
        conflicts: [],
        preferredPeriods: [],
        requiredPeriods: [],
        avoidPeriods: []
      }
    };
    setClasses([...classes, newClass]);
    setSelectedClassId(newClass.id);
  };

  const removeClass = () => {
    if (!selectedClassId) return;
    setClasses(classes.filter(c => c.id !== selectedClassId));
    setSelectedClassId(classes[0]?.id || '');
  };

  const updateEditedClass = (updates: Partial<Class>) => {
    if (!editedClass) return;
    setEditedClass({ ...editedClass, ...updates });
    setHasUnsavedChanges(true);
  };

  const saveChanges = () => {
    if (!editedClass) return;
    setClasses(classes.map(c => 
      c.id === editedClass.id ? editedClass : c
    ));
    setHasUnsavedChanges(false);
  };

  const getCellState = (day: number, period: number): CellState => {
    if (!editedClass) return 'blank';
    
    const isConflict = editedClass.weeklySchedule.conflicts.some(
      c => c.dayOfWeek === day && c.period === period
    );
    
    const isRequired = editedClass.weeklySchedule.requiredPeriods.some(
      r => r.dayOfWeek === day && r.period === period
    );
    
    const isPreferred = editedClass.weeklySchedule.preferredPeriods.some(
      p => p.dayOfWeek === day && p.period === period
    );

    const isAvoid = editedClass.weeklySchedule.avoidPeriods.some(
      a => a.dayOfWeek === day && a.period === period
    );
    
    if (isConflict) return 'conflict';
    if (isRequired) return 'required';
    if (isPreferred) return 'preferred';
    if (isAvoid) return 'avoid';
    return 'blank';
  };

  const toggleCellState = (day: number, period: number) => {
    if (!editedClass) return;

    const currentState = getCellState(day, period);
    const timeSlot: TimeSlot = { dayOfWeek: day, period };

    let newConflicts = [...editedClass.weeklySchedule.conflicts];
    let newPreferred = [...editedClass.weeklySchedule.preferredPeriods];
    let newRequired = [...editedClass.weeklySchedule.requiredPeriods];
    let newAvoid = [...editedClass.weeklySchedule.avoidPeriods];

    switch (currentState) {
      case 'blank':
        // Blank â†’ Conflict
        newConflicts = [...newConflicts, timeSlot];
        break;
      case 'conflict':
        // Conflict â†’ Preferred
        newConflicts = newConflicts.filter(
          c => !(c.dayOfWeek === day && c.period === period)
        );
        newPreferred = [...newPreferred, timeSlot];
        break;
      case 'preferred':
        // Preferred â†’ Required
        newPreferred = newPreferred.filter(
          p => !(p.dayOfWeek === day && p.period === period)
        );
        newRequired = [...newRequired, timeSlot];
        break;
      case 'required':
        // Required â†’ Avoid
        newRequired = newRequired.filter(
          r => !(r.dayOfWeek === day && r.period === period)
        );
        newAvoid = [...newAvoid, timeSlot];
        break;
      case 'avoid':
        // Avoid â†’ Blank
        newAvoid = newAvoid.filter(
          a => !(a.dayOfWeek === day && a.period === period)
        );
        break;
    }

    updateEditedClass({
      weeklySchedule: {
        conflicts: newConflicts,
        preferredPeriods: newPreferred,
        requiredPeriods: newRequired,
        avoidPeriods: newAvoid
      }
    });
  };

  const setGradeLunch = () => {
    if (!gradeLunchPeriod) return;

    const updatedClasses = classes.map(classObj => {
      if (classObj.grade !== selectedGrade) return classObj;

      const nonLunchConflicts = classObj.weeklySchedule.conflicts.filter(
        conflict => !DAYS.some((_, idx) => 
          conflict.dayOfWeek === idx + 1 && conflict.period === gradeLunchPeriod
        )
      );

      const lunchConflicts = DAYS.map((_, idx) => ({
        dayOfWeek: idx + 1,
        period: gradeLunchPeriod
      }));

      return {
        ...classObj,
        weeklySchedule: {
          ...classObj.weeklySchedule,
          conflicts: [...nonLunchConflicts, ...lunchConflicts]
        }
      };
    });

    setClasses(updatedClasses);
    if (editedClass?.grade === selectedGrade) {
      const updatedClass = updatedClasses.find(c => c.id === editedClass.id);
      if (updatedClass) setEditedClass(updatedClass);
    }
  };

  if (classes.length === 0) {
    return (
      <div className="bg-white p-6 rounded-lg shadow-md text-center">
        <p className="text-gray-500 mb-4">No classes available. Add a class or import from CSV.</p>
        <button
          onClick={addClass}
          className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 mx-auto"
        >
          <PlusCircle size={20} />
          Add Class
        </button>
      </div>
    );
  }

  return (
    <div className="bg-white p-6 rounded-lg shadow-md">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-xl font-semibold">Class Editor</h2>
        <div className="flex items-center gap-2">
          <button
            onClick={addClass}
            className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600"
          >
            <PlusCircle size={20} />
            Add Class
          </button>
        </div>
      </div>

      <div className="mb-6 p-4 bg-blue-50 rounded-lg">
        <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
          <Clock size={20} className="text-blue-500" />
          Set Grade Lunch Periods
        </h3>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700">
              Grade
              <select
                value={selectedGrade}
                onChange={(e) => setSelectedGrade(e.target.value)}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              >
                {GRADES.map(grade => (
                  <option key={grade} value={grade}>{grade}</option>
                ))}
              </select>
            </label>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700">
              Lunch Period
              <select
                value={gradeLunchPeriod}
                onChange={(e) => setGradeLunchPeriod(Number(e.target.value))}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              >
                <option value={0}>Select period</option>
                {PERIODS.map(period => (
                  <option key={period} value={period}>{period}</option>
                ))}
              </select>
            </label>
          </div>
          <div className="flex items-end">
            <button
              onClick={setGradeLunch}
              disabled={!gradeLunchPeriod}
              className="w-full px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
            >
              Set Lunch Period
            </button>
          </div>
        </div>
        <p className="text-sm text-gray-600 mt-2">
          This will set the lunch period for all classes in the selected grade. For "multiple" grade classes, set lunch periods individually.
        </p>
      </div>

      <div className="mb-6">
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Select Class
          <select
            value={selectedClassId}
            onChange={(e) => setSelectedClassId(e.target.value)}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
          >
            {classes.map(c => (
              <option key={c.id} value={c.id}>{c.name || 'Unnamed Class'}</option>
            ))}
          </select>
        </label>
      </div>

      {editedClass && (
        <div className="border rounded-lg p-4">
          <div className="flex items-start justify-between mb-4">
            <div className="flex-1 grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700">
                  Class Name
                  <input
                    type="text"
                    value={editedClass.name}
                    onChange={(e) => updateEditedClass({ name: e.target.value })}
                    placeholder="e.g., 1-409"
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  />
                </label>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">
                  Grade Level
                  <select
                    value={editedClass.grade}
                    onChange={(e) => updateEditedClass({ grade: e.target.value })}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  >
                    {GRADES.map(grade => (
                      <option key={grade} value={grade}>{grade}</option>
                    ))}
                  </select>
                </label>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <button
                onClick={saveChanges}
                disabled={!hasUnsavedChanges}
                className={`flex items-center gap-2 px-4 py-2 rounded-lg ${
                  hasUnsavedChanges
                    ? 'bg-green-500 text-white hover:bg-green-600'
                    : 'bg-gray-100 text-gray-400 cursor-not-allowed'
                }`}
                title={hasUnsavedChanges ? 'Save changes' : 'No changes to save'}
              >
                <Save size={20} />
                Save
              </button>
              <button
                onClick={removeClass}
                className="p-2 text-red-500 hover:text-red-600"
                title="Remove class"
              >
                <Trash2 size={20} />
              </button>
            </div>
          </div>

          <div className="mt-4">
            <h3 className="text-sm font-medium text-gray-700 mb-2">Schedule Grid</h3>
            <div className="bg-blue-50 p-4 rounded-lg mb-4">
              <p className="text-sm text-gray-600">
                Click cells to toggle between states:
                <span className="inline-flex items-center gap-2 ml-2">
                  <span className="w-4 h-4 bg-gray-50 rounded"></span> Available
                  <span className="w-4 h-4 bg-red-100 rounded"></span> Conflict
                  <span className="w-4 h-4 bg-green-100 rounded"></span> Preferred
                  <span className="w-4 h-4 bg-amber-200 rounded"></span> Required
                  <span className="w-4 h-4 bg-purple-100 rounded"></span> Avoid
                </span>
              </p>
            </div>
            <div className="overflow-x-auto">
              <table className="min-w-full border border-gray-200">
                <thead>
                  <tr>
                    <th className="border p-2">Period</th>
                    {DAYS.map(day => (
                      <th key={day} className="border p-2">{day}</th>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {PERIODS.map(period => (
                    <tr key={period}>
                      <td className="border p-2 font-medium">{period}</td>
                      {DAYS.map((_, dayIndex) => {
                        const state = getCellState(dayIndex + 1, period);
                        return (
                          <td
                            key={dayIndex}
                            className="border p-2"
                            onClick={() => toggleCellState(dayIndex + 1, period)}
                          >
                            <div
                              className={`w-full h-8 rounded cursor-pointer transition-colors ${
                                state === 'conflict'
                                  ? 'bg-red-100 hover:bg-red-200'
                                  : state === 'preferred'
                                  ? 'bg-green-100 hover:bg-green-200'
                                  : state === 'required'
                                  ? 'bg-amber-200 hover:bg-amber-300'
                                  : state === 'avoid'
                                  ? 'bg-purple-100 hover:bg-purple-200'
                                  : 'bg-gray-50 hover:bg-gray-100'
                              }`}
                            />
                          </td>
                        );
                      })}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

================
File: src/components/ConstraintsForm.tsx
================
import React from 'react';
import { Settings, Loader2 } from 'lucide-react';
import { useScheduleStore } from '../store/scheduleStore';
import { format, parseISO } from 'date-fns';

export const ConstraintsForm: React.FC = () => {
  const { constraints, setConstraints, isGenerating, generationProgress } = useScheduleStore();

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target;
    
    if (type === 'date') {
      const date = new Date(`${value}T00:00:00`);
      if (!isNaN(date.getTime())) {
        setConstraints({
          [name]: date.toISOString()
        });
      }
    } else if (name === 'maxConsecutiveClasses') {
      setConstraints({
        [name]: parseInt(value, 10) as 1 | 2
      });
    } else if (name === 'consecutiveClassesRule') {
      setConstraints({
        [name]: value as 'hard' | 'soft'
      });
    } else {
      const numValue = parseInt(value, 10);
      if (!isNaN(numValue)) {
        setConstraints({
          [name]: numValue
        });
      }
    }
  };

  const formatDate = (dateString: string) => {
    try {
      const date = parseISO(dateString);
      if (isNaN(date.getTime())) {
        return format(new Date(), 'yyyy-MM-dd');
      }
      return format(date, 'yyyy-MM-dd');
    } catch {
      return format(new Date(), 'yyyy-MM-dd');
    }
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow-md">
      <div className="flex items-center gap-2 mb-4">
        <Settings className="text-blue-500" />
        <h2 className="text-xl font-semibold">Schedule Constraints</h2>
      </div>

      <div className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label className="block text-sm font-medium text-gray-700">
              Start Date
              <input
                type="date"
                name="startDate"
                value={formatDate(constraints.startDate)}
                onChange={handleChange}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              />
            </label>
            <p className="mt-1 text-sm text-gray-500">
              When should the rotation schedule begin?
            </p>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700">
              End Date
              <input
                type="date"
                name="endDate"
                value={formatDate(constraints.endDate)}
                onChange={handleChange}
                min={formatDate(constraints.startDate)}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              />
            </label>
            <p className="mt-1 text-sm text-gray-500">
              When should the rotation schedule end?
            </p>
          </div>
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700">
            Maximum Classes Per Day
            <input
              type="number"
              name="maxClassesPerDay"
              value={constraints.maxClassesPerDay}
              onChange={handleChange}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              min="1"
              max="8"
            />
          </label>
          <p className="mt-1 text-sm text-gray-500">
            Maximum number of classes that can be scheduled in a single day
          </p>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label className="block text-sm font-medium text-gray-700">
              Maximum Classes Per Week
              <input
                type="number"
                name="maxClassesPerWeek"
                value={constraints.maxClassesPerWeek}
                onChange={handleChange}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                min="1"
                max="40"
              />
            </label>
            <p className="mt-1 text-sm text-gray-500">
              Maximum number of classes that can be scheduled in a week
            </p>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700">
              Minimum Classes Per Week
              <input
                type="number"
                name="minPeriodsPerWeek"
                value={constraints.minPeriodsPerWeek}
                onChange={handleChange}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                min="1"
                max={constraints.maxClassesPerWeek}
              />
            </label>
            <p className="mt-1 text-sm text-gray-500">
              Minimum number of classes that must be scheduled each week (pro-rated for partial weeks)
            </p>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label className="block text-sm font-medium text-gray-700">
              Maximum Consecutive Classes
              <select
                name="maxConsecutiveClasses"
                value={constraints.maxConsecutiveClasses}
                onChange={handleChange}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              >
                <option value={1}>1 class</option>
                <option value={2}>2 classes</option>
              </select>
            </label>
            <p className="mt-1 text-sm text-gray-500">
              Maximum number of classes that can be scheduled consecutively
            </p>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700">
              Consecutive Classes Rule
              <select
                name="consecutiveClassesRule"
                value={constraints.consecutiveClassesRule}
                onChange={handleChange}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              >
                <option value="hard">Hard constraint (strictly enforced)</option>
                <option value="soft">Soft constraint (preferred but not required)</option>
              </select>
            </label>
            <p className="mt-1 text-sm text-gray-500">
              Determines whether the consecutive classes limit is strictly enforced or just preferred
            </p>
          </div>
        </div>
      </div>

      {isGenerating && (
        <div className="mt-6 bg-blue-50 p-4 rounded-lg">
          <div className="flex items-center gap-2 mb-2">
            <Loader2 className="animate-spin text-blue-500" />
            <span className="font-medium">Generating Schedule...</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2.5">
            <div 
              className="bg-blue-500 h-2.5 rounded-full transition-all duration-300" 
              style={{ width: `${generationProgress}%` }}
            />
          </div>
          <p className="mt-2 text-sm text-gray-600">
            This may take a few moments. The schedule is being optimized to meet all constraints.
          </p>
        </div>
      )}
    </div>
  );
};

================
File: src/components/FileUpload.tsx
================
import React, { useCallback } from 'react';
import { Upload, Info } from 'lucide-react';
import { parseClassesCSV } from '../lib/csvParser';
import { useScheduleStore } from '../store/scheduleStore';

export const FileUpload: React.FC = () => {
  const { setClasses } = useScheduleStore();

  const handleFileUpload = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const text = e.target?.result as string;
      const classes = parseClassesCSV(text);
      setClasses(classes);
    };
    reader.readAsText(file);
  }, [setClasses]);

  return (
    <div className="space-y-4">
      <div className="flex flex-col gap-4">
        <div className="bg-blue-50 p-4 rounded-lg">
          <div className="flex items-center gap-2 mb-2">
            <Info className="text-blue-500" />
            <h3 className="font-medium">File Format Guidelines</h3>
          </div>
          <div className="text-sm text-gray-600">
            <p><strong>Classes CSV format:</strong> Name, Conflicts</p>
            <p className="text-xs mt-1">Example: 1-409, 1-3,2-4,3-6 (conflicts on Monday period 3, Tuesday period 4, Wednesday period 6)</p>
          </div>
        </div>

        <div className="flex items-center gap-4">
          <label className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg cursor-pointer hover:bg-blue-600">
            <Upload size={20} />
            <span>Upload Classes List</span>
            <input
              type="file"
              accept=".csv"
              className="hidden"
              onChange={handleFileUpload}
            />
          </label>
        </div>
      </div>
    </div>
  );
};

================
File: src/components/InstructorAvailability.tsx
================
import React from 'react';
import { Calendar as CalendarIcon, ChevronLeft, ChevronRight } from 'lucide-react';
import { format, addWeeks, startOfWeek, endOfWeek, eachDayOfInterval } from 'date-fns';
import { useScheduleStore } from '../store/scheduleStore';

const PERIODS = Array.from({ length: 8 }, (_, i) => i + 1);
const DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

export const InstructorAvailability: React.FC = () => {
  const { setInstructorAvailability, instructorAvailability } = useScheduleStore();
  const [currentWeek, setCurrentWeek] = React.useState(new Date());
  
  const weekDates = React.useMemo(() => {
    const start = startOfWeek(currentWeek, { weekStartsOn: 1 });
    const end = endOfWeek(currentWeek, { weekStartsOn: 1 });
    return eachDayOfInterval({ start, end }).slice(0, 5); // Monday to Friday
  }, [currentWeek]);

  const isUnavailable = (date: Date, period: number): boolean => {
    const dateStr = format(date, 'yyyy-MM-dd');
    const dayAvailability = instructorAvailability.find(a => a.date === dateStr);
    return dayAvailability?.periods.includes(period) || false;
  };

  const toggleSlot = (date: Date, period: number) => {
    const dateStr = format(date, 'yyyy-MM-dd');
    const isCurrentlyUnavailable = isUnavailable(date, period);

    setInstructorAvailability(prev => {
      const currentAvailability = [...prev];
      const dayIndex = currentAvailability.findIndex(a => a.date === dateStr);
      
      // Initialize day if it doesn't exist
      if (dayIndex === -1) {
        if (!isCurrentlyUnavailable) {
          return [...currentAvailability, {
            date: dateStr,
            periods: [period]
          }];
        }
        return currentAvailability;
      }

      const day = { ...currentAvailability[dayIndex] };
      
      if (isCurrentlyUnavailable) {
        // Remove period from unavailable list
        day.periods = day.periods.filter(p => p !== period);
        // If no periods left, remove the day entry
        if (day.periods.length === 0) {
          return currentAvailability.filter(a => a.date !== dateStr);
        }
      } else {
        // Add period to unavailable list
        day.periods = [...day.periods, period];
      }

      return [
        ...currentAvailability.slice(0, dayIndex),
        day,
        ...currentAvailability.slice(dayIndex + 1)
      ];
    });
  };

  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-xl font-semibold flex items-center gap-2">
          <CalendarIcon className="text-blue-500" />
          Set Your Unavailable Times
        </h2>
        <div className="flex items-center gap-2">
          <button
            onClick={() => setCurrentWeek(prev => addWeeks(prev, -1))}
            className="p-2 hover:bg-gray-100 rounded-full"
          >
            <ChevronLeft />
          </button>
          <span className="font-medium">
            Week of {format(weekDates[0], 'MMM d, yyyy')}
          </span>
          <button
            onClick={() => setCurrentWeek(prev => addWeeks(prev, 1))}
            className="p-2 hover:bg-gray-100 rounded-full"
          >
            <ChevronRight />
          </button>
        </div>
      </div>

      <div className="bg-blue-50 p-4 rounded-lg mb-6">
        <p className="text-sm text-gray-600">
          Click cells to toggle between states:
          <span className="inline-flex items-center gap-2 ml-2">
            <span className="w-4 h-4 bg-gray-50 rounded"></span> Available
            <span className="w-4 h-4 bg-red-100 rounded"></span> Unavailable
          </span>
        </p>
      </div>

      <div className="overflow-x-auto">
        <table className="min-w-full border border-gray-200">
          <thead>
            <tr>
              <th className="border p-2">Period</th>
              {weekDates.map(date => (
                <th key={date.toISOString()} className="border p-2">
                  <div>{DAYS[date.getDay() - 1]}</div>
                  <div className="text-sm text-gray-500">
                    {format(date, 'MMM d')}
                  </div>
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {PERIODS.map(period => (
              <tr key={period}>
                <td className="border p-2 font-medium">{period}</td>
                {weekDates.map(date => (
                  <td
                    key={date.toISOString()}
                    className="border p-2"
                    onClick={() => toggleSlot(date, period)}
                  >
                    <div
                      className={`w-full h-8 rounded cursor-pointer transition-colors ${
                        isUnavailable(date, period)
                          ? 'bg-red-100 hover:bg-red-200'
                          : 'bg-gray-50 hover:bg-gray-100'
                      }`}
                    />
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

================
File: src/components/ScheduleComparison.tsx
================
import React from 'react';
import { GitCompare } from 'lucide-react';
import type { ScheduleComparisonProps } from '../store/types';

export const ScheduleComparison: React.FC<ScheduleComparisonProps> = ({
  result,
  isComparing,
  onCompare
}) => {
  if (!result && !isComparing) {
    return (
      <div className="bg-gray-50 p-3 rounded">
        <div className="flex items-center justify-between">
          <h4 className="font-medium">Version Comparison</h4>
          <button
            onClick={onCompare}
            disabled={isComparing}
            className="flex items-center gap-1 px-2 py-1 text-sm bg-blue-50 text-blue-600 rounded hover:bg-blue-100 disabled:opacity-50"
            title="Compare stable and dev versions"
          >
            <GitCompare size={16} />
            Compare Versions
          </button>
        </div>
      </div>
    );
  }

  if (isComparing) {
    return (
      <div className="bg-gray-50 p-3 rounded">
        <div className="flex items-center justify-between">
          <h4 className="font-medium">Version Comparison</h4>
          <div className="flex items-center gap-2 text-blue-600">
            <GitCompare size={16} className="animate-spin" />
            <span className="text-sm">Comparing...</span>
          </div>
        </div>
      </div>
    );
  }

  // At this point, result must be non-null because we've handled all other cases
  if (!result) return null;

  return (
    <section>
      <div className="flex items-center justify-between mb-2">
        <h4 className="font-medium">Version Comparison</h4>
        <button
          onClick={onCompare}
          className="flex items-center gap-1 px-2 py-1 text-sm bg-blue-50 text-blue-600 rounded hover:bg-blue-100"
          title="Run comparison again"
        >
          <GitCompare size={16} />
          Compare Again
        </button>
      </div>

      <div className="bg-gray-50 p-3 rounded space-y-4">
        <div>
          <h5 className="text-sm font-medium mb-1">Schedule Differences:</h5>
          <div className="text-sm">
            Total differences: {result.differences.total_differences}
          </div>
          {result.differences.total_differences > 0 && (
            <div className="mt-2 space-y-2">
              {result.differences.differences.map((diff, index) => (
                <div 
                  key={index} 
                  className="border-l-4 pl-2"
                  style={{
                    borderColor: diff.type === 'missing_in_stable' ? '#dc2626' :
                               diff.type === 'missing_in_dev' ? '#f59e0b' : '#16a34a'
                  }}
                >
                  <div className="font-medium">Class {diff.classId}</div>
                  <div className="text-sm">
                    {diff.type === 'different_assignment' ? (
                      <>
                        Stable: Day {diff.stable?.timeSlot.dayOfWeek}, 
                        Period {diff.stable?.timeSlot.period}
                        <br />
                        Dev: Day {diff.dev?.timeSlot.dayOfWeek}, 
                        Period {diff.dev?.timeSlot.period}
                      </>
                    ) : (
                      `Missing in ${diff.type === 'missing_in_stable' ? 'stable' : 'dev'} version`
                    )}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        <div>
          <h5 className="text-sm font-medium mb-1">Performance Comparison:</h5>
          <div className="space-y-1">
            <div className="text-sm">
              Score difference: {result.metrics.score > 0 ? '+' : ''}
              {result.metrics.score}
              {result.metrics.score !== 0 && (
                <span className="text-xs ml-1">
                  ({result.metrics.score > 0 ? 'dev better' : 'stable better'})
                </span>
              )}
            </div>
            <div className="text-sm">
              Duration difference: {result.metrics.duration}ms
              {result.metrics.duration !== 0 && (
                <span className="text-xs ml-1">
                  ({result.metrics.duration < 0 ? 'dev faster' : 'stable faster'})
                </span>
              )}
            </div>
          </div>
        </div>

        <div>
          <h5 className="text-sm font-medium mb-1">Distribution Improvements:</h5>
          <div className="space-y-1">
            <div className="text-sm">
              Weekly variance: {result.metrics.distribution.weekly_variance_difference > 0 ? '+' : ''}
              {result.metrics.distribution.weekly_variance_difference.toFixed(2)}
            </div>
            <div className="text-sm">
              Period spread: {result.metrics.distribution.average_period_spread_difference > 0 ? '+' : ''}
              {(result.metrics.distribution.average_period_spread_difference * 100).toFixed(1)}%
            </div>
            <div className="text-sm">
              Overall distribution: {result.metrics.distribution.score_difference > 0 ? '+' : ''}
              {result.metrics.distribution.score_difference.toFixed(0)}
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

================
File: src/components/ScheduleDebugPanel.tsx
================
import React from 'react';
import { useScheduleStore } from '../store/scheduleStore';
import { format } from 'date-fns';
import { Bug, Download, Zap, AlertCircle, XCircle } from 'lucide-react';
import type { Class, TeacherAvailability, TimeSlot } from '../types';
import { ScheduleComparison } from './ScheduleComparison';

interface ScheduleStats {
  totalAssignments: number;
  assignmentsPerDay: { [key: string]: number };
  assignmentsPerClass: { [key: string]: number };
  periodsUsed: { [key: string]: number };
  consecutiveClasses: { [key: string]: number };
  requiredPeriodStats: {
    totalClassesWithRequired: number;
    satisfiedRequirements: { [key: string]: boolean };
  };
  preferenceStats: {
    totalPreferred: number;
    totalAvoided: number;
    satisfiedPreferences: { [key: string]: boolean };
    avoidedPeriods: { [key: string]: boolean };
  };
}

export const ScheduleDebugPanel: React.FC = () => {
  const { 
    assignments, 
    classes, 
    constraints,
    solverDecision,
    lastGenerationMetadata,
    schedulerVersion,
    setSchedulerVersion,
    teacherAvailability,
    comparisonResult,
    isComparing,
    compareVersions,
    error,
    clearError
  } = useScheduleStore();
  const [isOpen, setIsOpen] = React.useState(false);

  const calculateStats = (): ScheduleStats => {
    // ... [Previous calculateStats implementation remains the same]
    const stats: ScheduleStats = {
      totalAssignments: assignments.length,
      assignmentsPerDay: {},
      assignmentsPerClass: {},
      periodsUsed: {},
      consecutiveClasses: {},
      requiredPeriodStats: {
        totalClassesWithRequired: 0,
        satisfiedRequirements: {}
      },
      preferenceStats: {
        totalPreferred: 0,
        totalAvoided: 0,
        satisfiedPreferences: {},
        avoidedPeriods: {}
      }
    };

    // ... [Rest of calculateStats stays the same]
    return stats;
  };

  const downloadScheduleData = () => {
    const stats = calculateStats();
    const data = {
      schedulerVersion,
      constraints,
      overview: {
        totalAssignments: stats.totalAssignments,
        totalClasses: classes.length,
        classesWithRequiredPeriods: stats.requiredPeriodStats.totalClassesWithRequired,
        requiredPeriodAssignments: classes
          .filter(c => c.weeklySchedule.requiredPeriods.length > 0)
          .map(c => {
            const assignment = assignments.find(a => a.classId === c.id);
            const isRequired = assignment && c.weeklySchedule.requiredPeriods.some(
              rp => rp.dayOfWeek === assignment.timeSlot.dayOfWeek && 
                   rp.period === assignment.timeSlot.period
            );
            return {
              classId: c.id,
              requiredPeriods: c.weeklySchedule.requiredPeriods,
              assignedSlot: assignment?.timeSlot,
              satisfiesRequirement: isRequired
            };
          })
      },
      assignmentsPerDay: stats.assignmentsPerDay,
      assignmentsPerClass: stats.assignmentsPerClass,
      periodsUsed: stats.periodsUsed,
      consecutiveClasses: stats.consecutiveClasses,
      rawSchedule: assignments,
      metadata: lastGenerationMetadata,
      comparison: comparisonResult
    };

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `schedule-data-${format(new Date(), 'yyyy-MM-dd')}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const stats = calculateStats();

  if (!isOpen) {
    return (
      <button
        onClick={() => setIsOpen(true)}
        className="fixed bottom-4 right-4 p-2 bg-gray-800 text-white rounded-full shadow-lg hover:bg-gray-700"
        title="Open Schedule Debug Panel"
      >
        <Bug size={24} />
      </button>
    );
  }

  return (
    <div className="fixed bottom-4 right-4 w-96 max-h-[80vh] bg-white rounded-lg shadow-xl border border-gray-200 overflow-hidden">
      <div className="p-4 bg-gray-800 text-white flex items-center justify-between">
        <h3 className="text-lg font-semibold flex items-center gap-2">
          <Bug size={20} />
          Schedule Debug Panel
        </h3>
        <div className="flex items-center gap-2">
          <button
            onClick={downloadScheduleData}
            className="p-1.5 rounded hover:bg-gray-700 transition-colors"
            title="Download Schedule Data"
          >
            <Download size={20} />
          </button>
          <button
            onClick={() => setIsOpen(false)}
            className="text-gray-400 hover:text-white"
          >
            Ã—
          </button>
        </div>
      </div>
      
      <div className="p-4 overflow-y-auto max-h-[calc(80vh-4rem)]">
        <div className="space-y-6">
          {error && (
            <div className="bg-red-50 border-l-4 border-red-500 p-4 flex items-start gap-3">
              <AlertCircle className="text-red-500 shrink-0 mt-0.5" size={20} />
              <div className="flex-1">
                <p className="text-red-700 whitespace-pre-wrap">{error}</p>
              </div>
              <button
                onClick={clearError}
                className="text-red-400 hover:text-red-600"
                title="Dismiss error"
              >
                <XCircle size={20} />
              </button>
            </div>
          )}

          <section>
            <h4 className="font-medium mb-2">Scheduler Version</h4>
            <div className="bg-gray-50 p-3 rounded">
              <select 
                value={schedulerVersion}
                onChange={(e) => setSchedulerVersion(e.target.value as 'stable' | 'dev')}
                className="w-full p-2 border rounded"
              >
                <option value="stable">CP-SAT Stable (Full Featured)</option>
                <option value="dev">CP-SAT Dev - Advanced Optimization</option>
              </select>
              <div className="mt-2 text-sm text-gray-600">
                {schedulerVersion === 'stable' && 'Stable version with class limits, required periods, period preferences, and consecutive class handling'}
                {schedulerVersion === 'dev' && 'Development version: Adding advanced schedule distribution optimization'}
              </div>
            </div>
          </section>

          <ScheduleComparison
            result={comparisonResult}
            isComparing={isComparing}
            onCompare={compareVersions}
          />

          {solverDecision && (
            <section>
              <h4 className="font-medium mb-2 flex items-center gap-2">
                <Zap size={16} className="text-yellow-500" />
                Solver Decision
              </h4>
              <div className="bg-gray-50 p-3 rounded space-y-2">
                <p className="font-medium">
                  Using {solverDecision.solver} solver
                </p>
                <p className="text-sm text-gray-600">
                  {solverDecision.reason}
                </p>
                <div className="mt-2">
                  <h5 className="text-sm font-medium mb-1">Complexity Metrics:</h5>
                  <pre className="text-sm">
                    {JSON.stringify({
                      totalClasses: solverDecision.metrics.totalClasses,
                      totalDays: solverDecision.metrics.totalDays,
                      constraintComplexity: solverDecision.metrics.constraintComplexity,
                      teacherConflicts: solverDecision.metrics.teacherConflicts,
                      overallComplexity: solverDecision.metrics.overallComplexity
                    }, null, 2)}
                  </pre>
                </div>
              </div>
            </section>
          )}

          {lastGenerationMetadata && (
            <section>
              <h4 className="font-medium mb-2">Generation Results</h4>
              <div className="bg-gray-50 p-3 rounded">
                <pre className="text-sm">
                  {JSON.stringify({
                    solver: lastGenerationMetadata.solver,
                    duration: `${lastGenerationMetadata.duration}ms`,
                    score: lastGenerationMetadata.score,
                    distribution: lastGenerationMetadata.distribution
                  }, null, 2)}
                </pre>
              </div>
            </section>
          )}

          <section>
            <h4 className="font-medium mb-2">Schedule Overview</h4>
            <div className="bg-gray-50 p-3 rounded space-y-4">
              <div>
                <p>Total Assignments: {stats.totalAssignments}</p>
                <p>Total Classes: {classes.length}</p>
              </div>
              
              <div className="border-t pt-2">
                <h5 className="text-sm font-medium mb-1">Assignments per Day:</h5>
                <pre className="text-sm">
                  {JSON.stringify(stats.assignmentsPerDay, null, 2)}
                </pre>
              </div>
              
              <div className="border-t pt-2">
                <h5 className="text-sm font-medium mb-1">Assignments per Class:</h5>
                <pre className="text-sm">
                  {JSON.stringify(stats.assignmentsPerClass, null, 2)}
                </pre>
              </div>
              
              <div className="border-t pt-2">
                <h5 className="text-sm font-medium mb-1">Period Usage:</h5>
                <pre className="text-sm">
                  {JSON.stringify(stats.periodsUsed, null, 2)}
                </pre>
              </div>
            </div>
          </section>

          <section>
            <h4 className="font-medium mb-2">Raw Schedule Data</h4>
            <div className="bg-gray-50 p-3 rounded">
              <pre className="text-sm">
                {JSON.stringify(assignments, null, 2)}
              </pre>
            </div>
          </section>
        </div>
      </div>
    </div>
  );
};

================
File: src/components/SolverConfig.css
================
/* Custom slider styles */
input[type="range"] {
  -webkit-appearance: none;
  margin: 10px 0;
  width: 100%;
}

input[type="range"]:focus {
  outline: none;
}

/* Slider track */
input[type="range"]::-webkit-slider-runnable-track {
  height: 8px;
  border-radius: 4px;
  cursor: pointer;
}

input[type="range"]::-moz-range-track {
  height: 8px;
  border-radius: 4px;
  cursor: pointer;
}

/* Slider thumb */
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 20px;
  width: 20px;
  border-radius: 50%;
  background: white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  cursor: pointer;
  margin-top: -6px;
  border: 2px solid #3b82f6;
  transition: all 0.2s ease;
}

input[type="range"]::-moz-range-thumb {
  height: 20px;
  width: 20px;
  border-radius: 50%;
  background: white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  cursor: pointer;
  border: 2px solid #3b82f6;
  transition: all 0.2s ease;
}

/* Hover state */
input[type="range"]:hover::-webkit-slider-thumb {
  transform: scale(1.1);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
}

input[type="range"]:hover::-moz-range-thumb {
  transform: scale(1.1);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
}

/* Negative value sliders */
input[type="range"].negative::-webkit-slider-thumb {
  border-color: #ef4444;
}

input[type="range"].negative::-moz-range-thumb {
  border-color: #ef4444;
}

/* Focus state */
input[type="range"]:focus::-webkit-slider-thumb {
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
}

input[type="range"]:focus::-moz-range-thumb {
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
}

/* Animation for saving */
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

.saving-indicator {
  animation: pulse 1s infinite;
}

================
File: src/components/SolverConfig.tsx
================
import React, { useState, useEffect } from 'react';
import { apiClient } from '../lib/apiClient';
import { SolverWeights } from '../types';
import './SolverConfig.css';

type PresetType = 'balanced' | 'strict' | 'teacher' | 'rapid' | 'custom';

const presets: Record<PresetType, { name: string; description: string; weights: SolverWeights }> = {
  balanced: {
    name: 'Balanced Schedule',
    description: 'Even distribution of classes with moderate priorities',
    weights: {
      final_week_compression: 3000,
      day_usage: 2000,
      daily_balance: 1500,
      preferred_periods: 1000,
      distribution: 1000,
      avoid_periods: -500,
      earlier_dates: 10,
    }
  },
  strict: {
    name: 'Strict Requirements',
    description: 'Highest priority for preferred periods and scheduling rules',
    weights: {
      final_week_compression: 4000,
      day_usage: 2500,
      daily_balance: 2000,
      preferred_periods: 1500,
      distribution: 1200,
      avoid_periods: -1000,
      earlier_dates: 5,
    }
  },
  teacher: {
    name: 'Teacher Friendly',
    description: 'Focus on teacher preferences and balanced workload',
    weights: {
      final_week_compression: 2000,
      day_usage: 1500,
      daily_balance: 2000,
      preferred_periods: 3000,
      distribution: 1500,
      avoid_periods: -2000,
      earlier_dates: 0,
    }
  },
  rapid: {
    name: 'Flexible Schedule',
    description: 'More flexible scheduling with fewer constraints',
    weights: {
      final_week_compression: 1000,
      day_usage: 1000,
      daily_balance: 1000,
      preferred_periods: 500,
      distribution: 500,
      avoid_periods: -200,
      earlier_dates: 50,
    }
  },
  custom: {
    name: 'Custom Settings',
    description: 'Fine-tune all settings manually',
    weights: {
      final_week_compression: 3000,
      day_usage: 2000,
      daily_balance: 1500,
      preferred_periods: 1000,
      distribution: 1000,
      avoid_periods: -500,
      earlier_dates: 10,
    }
  }
};

interface SettingConfig {
  key: keyof SolverWeights;
  label: string;
  description: string;
  isNegative?: boolean;
}

interface SettingGroup {
  title: string;
  description: string;
  settings: SettingConfig[];
}

const settingGroups: Record<string, SettingGroup> = {
  balance: {
    title: 'ðŸ“… Schedule Balance',
    description: 'Control how classes are distributed',
    settings: [
      {
        key: 'distribution',
        label: 'Even Class Spread',
        description: 'Spread classes evenly throughout available times'
      },
      {
        key: 'daily_balance',
        label: 'Daily Balance',
        description: 'Balance number of classes per day'
      }
    ]
  },
  priorities: {
    title: 'âš–ï¸ Scheduling Goals',
    description: 'Set your scheduling preferences',
    settings: [
      {
        key: 'final_week_compression',
        label: 'Avoid Last-Minute',
        description: 'Prevent too many classes in final weeks'
      },
      {
        key: 'preferred_periods',
        label: 'Preferred Times',
        description: 'Priority for teacher preferred time slots'
      }
    ]
  },
  conflicts: {
    title: 'ðŸš« Conflict Handling',
    description: 'Control how potential conflicts are handled',
    settings: [
      {
        key: 'avoid_periods',
        label: 'Avoid Conflicts',
        description: 'Strength of conflict avoidance',
        isNegative: true
      }
    ]
  }
};

export const SolverConfig: React.FC = () => {
  const [selectedPreset, setSelectedPreset] = useState<PresetType>('balanced');
  const [weights, setWeights] = useState<SolverWeights>(presets.balanced.weights);
  const [isSaving, setIsSaving] = useState(false);
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [showTour, setShowTour] = useState(false);
  const [currentTourStep, setCurrentTourStep] = useState(0);

  useEffect(() => {
    const hasSeenTour = localStorage.getItem('solverConfigTourSeen');
    if (!hasSeenTour) {
      setShowTour(true);
      localStorage.setItem('solverConfigTourSeen', 'true');
    }
  }, []);

  const tourSteps = [
    {
      title: 'Welcome to Schedule Settings! ðŸ‘‹',
      content: 'This tool helps you customize how flexible periods are scheduled. Required times are always respected.',
    },
    {
      title: 'Preset Configurations ðŸ“‹',
      content: 'Start with these preset options to quickly get the type of schedule you need.',
    },
    {
      title: 'Priority Sliders ðŸŽšï¸',
      content: 'Fine-tune individual settings by sliding left (lower priority) or right (higher priority).',
    },
    {
      title: 'Impact Indicators ðŸŽ¯',
      content: 'Green dots mean low impact, yellow medium, and red high impact on the schedule.',
    },
  ];

  const handlePresetChange = (preset: PresetType) => {
    setSelectedPreset(preset);
    setWeights(presets[preset].weights);
  };

  const [lastChanged, setLastChanged] = useState<keyof SolverWeights | null>(null);

  const handleWeightChange = (key: keyof SolverWeights) => (e: React.ChangeEvent<HTMLInputElement>) => {
    setLastChanged(key);
    setTimeout(() => setLastChanged(null), 1000);
    const value = parseInt(e.target.value);
    setWeights(prev => ({
      ...prev,
      [key]: value
    }));
    if (selectedPreset !== 'custom') {
      setSelectedPreset('custom');
    }
  };

  const handleSave = async () => {
    setIsSaving(true);
    try {
      await apiClient.updateSolverConfig(weights);
      alert('Settings saved successfully!');
    } catch (error) {
      alert('Failed to save settings');
      console.error('Error saving settings:', error);
    } finally {
      setIsSaving(false);
    }
  };

  const handleReset = () => {
    handlePresetChange('balanced');
  };

  const getImpactLevel = (value: number) => {
    const absValue = Math.abs(value);
    const percentage = (absValue / 10000) * 100;
    return percentage > 66 ? 'ðŸ”´' : percentage > 33 ? 'ðŸŸ¡' : 'ðŸŸ¢';
  };

  return (
    <div className="bg-white p-6 rounded-lg space-y-6">
      {showTour && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg max-w-md">
            <h3 className="text-xl font-semibold mb-2">{tourSteps[currentTourStep].title}</h3>
            <p className="text-gray-600 mb-4">{tourSteps[currentTourStep].content}</p>
            <div className="flex justify-between">
              <button
                onClick={() => setShowTour(false)}
                className="text-gray-500 hover:text-gray-700"
              >
                Skip Tour
              </button>
              <div className="flex gap-2">
                {currentTourStep > 0 && (
                  <button
                    onClick={() => setCurrentTourStep(prev => prev - 1)}
                    className="px-4 py-2 bg-gray-100 rounded hover:bg-gray-200"
                  >
                    Previous
                  </button>
                )}
                <button
                  onClick={() => {
                    if (currentTourStep === tourSteps.length - 1) {
                      setShowTour(false);
                    } else {
                      setCurrentTourStep(prev => prev + 1);
                    }
                  }}
                  className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                >
                  {currentTourStep === tourSteps.length - 1 ? 'Finish' : 'Next'}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      <div className="mb-8">
        <h2 className="text-2xl font-semibold mb-2">Schedule Settings</h2>
        <p className="text-gray-600">Choose a preset or customize your own settings</p>
        <div className="mt-2 space-y-2">
          <div className="p-3 bg-blue-50 text-blue-700 rounded-lg text-sm">
            <strong>Required Times:</strong> If a class has required time slots, those will always be respected and cannot be adjusted here.
          </div>
          <div className="p-3 bg-yellow-50 text-yellow-800 rounded-lg text-sm">
            <strong>Tip:</strong> Use these settings to control how flexible time slots are scheduled. Start with a preset and adjust if needed.
          </div>
        </div>
        <button 
          onClick={() => setShowTour(true)}
          className="text-sm text-blue-600 hover:text-blue-800 mt-2"
        >
          Show Tour Guide
        </button>
      </div>

      <div className="flex gap-2 mb-6 overflow-x-auto pb-2">
        {Object.entries(presets).map(([key, preset]) => (
          <button
            key={key}
            onClick={() => handlePresetChange(key as PresetType)}
            className={`px-4 py-2 rounded-lg text-sm whitespace-nowrap transition-colors ${
              selectedPreset === key
                ? 'bg-blue-600 text-white'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            {preset.name}
          </button>
        ))}
      </div>

      <div className="mb-6">
        <div className="text-sm text-gray-700 font-medium mb-2">
          {presets[selectedPreset].description}
        </div>
        <div className="text-xs text-gray-500">
          {selectedPreset === 'balanced' && "Recommended for most schedules"}
          {selectedPreset === 'strict' && "Best when you need very specific scheduling patterns"}
          {selectedPreset === 'teacher' && "Prioritizes teacher preferences and workload balance"}
          {selectedPreset === 'rapid' && "More flexible scheduling with fewer constraints"}
          {selectedPreset === 'custom' && "Your custom configuration"}
        </div>
      </div>

      {Object.entries(settingGroups).map(([groupKey, group]) => (
        <div key={groupKey} className="mb-8">
          <div className="mb-4">
            <h3 className="text-lg font-medium mb-1">{group.title}</h3>
            <p className="text-sm text-gray-600">{group.description}</p>
          </div>

          <div className="space-y-4">
            {group.settings.map(setting => (
              <div key={setting.key} className="bg-gray-50 p-4 rounded-lg">
                <div className="flex justify-between items-center mb-2">
                  <label className="font-medium">
                    {setting.label}
                    <span className="ml-2">
                      {getImpactLevel(weights[setting.key])}
                    </span>
                  </label>
                  <span className="text-sm text-gray-500">{weights[setting.key]}</span>
                </div>
                <div className={`relative ${lastChanged === setting.key ? 'saving-indicator' : ''}`}>
                  <input
                    type="range"
                    min={setting.isNegative ? -10000 : 0}
                    max={10000}
                    value={weights[setting.key]}
                    onChange={handleWeightChange(setting.key)}
                    className={`w-full appearance-none h-2 rounded cursor-pointer ${setting.isNegative ? 'negative' : ''}`}
                    title={`Drag to adjust ${setting.label.toLowerCase()} priority`}
                  />
                  <div className="text-xs text-gray-500 mt-1 flex justify-between">
                    <span>{setting.isNegative ? 'Stronger' : 'Low'}</span>
                    <span>{setting.isNegative ? 'Weaker' : 'High'}</span>
                  </div>
                </div>
                <p className="text-xs text-gray-500 mt-1">{setting.description}</p>
              </div>
            ))}
          </div>
        </div>
      ))}

      <div className="flex justify-between pt-4 border-t">
        <button
          onClick={handleReset}
          className="px-4 py-2 bg-gray-100 text-gray-700 rounded hover:bg-gray-200"
        >
          Reset to Default
        </button>
        <button
          onClick={handleSave}
          disabled={isSaving}
          className="px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
        >
          {isSaving ? 'Saving...' : 'Save Settings'}
        </button>
      </div>

      <div className="mt-4 pt-4 border-t">
        <button
          onClick={() => setShowAdvanced(!showAdvanced)}
          className="text-sm text-gray-600 hover:text-gray-800 flex items-center gap-1"
        >
          {showAdvanced ? 'ðŸ”¼' : 'ðŸ”½'} {showAdvanced ? 'Hide' : 'Show'} Advanced Settings
        </button>
        
        {showAdvanced && (
          <div className="mt-4 space-y-4">
            <div className="bg-gray-50 p-4 rounded-lg">
              <h4 className="font-medium mb-2">Day Usage Priority</h4>
              <input
                type="range"
                min={0}
                max={10000}
                value={weights.day_usage}
                onChange={handleWeightChange('day_usage')}
                className="w-full appearance-none h-2 rounded cursor-pointer"
              />
              <p className="text-xs text-gray-500 mt-1">
                Controls how much the scheduler tries to use all available days
              </p>
            </div>
            
            <div className="bg-gray-50 p-4 rounded-lg">
              <h4 className="font-medium mb-2">Earlier Dates Preference</h4>
              <input
                type="range"
                min={0}
                max={1000}
                value={weights.earlier_dates}
                onChange={handleWeightChange('earlier_dates')}
                className="w-full appearance-none h-2 rounded cursor-pointer"
              />
              <p className="text-xs text-gray-500 mt-1">
                Slight preference for scheduling classes earlier when possible
              </p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

================
File: src/lib/apiClient.ts
================
import type { 
  Class, 
  ScheduleAssignment, 
  ScheduleConstraints, 
  InstructorAvailability,
  ScheduleMetadata 
} from '../types';
import type { ComparisonResult } from '../store/types';

interface WeightConfig {
  final_week_compression: number;
  day_usage: number;
  daily_balance: number;
  preferred_periods: number;
  distribution: number;
  avoid_periods: number;
  earlier_dates: number;
}

class ApiClient {
  private baseUrl: string;

  constructor() {
    this.baseUrl = import.meta.env.PROD 
      ? '/api'  // Production URL
      : 'http://localhost:8000';  // FastAPI development URL
  }

  async generateSchedule(
    classes: Class[],
    instructorAvailability: InstructorAvailability[],
    constraints: ScheduleConstraints,
    version: SchedulerVersion = 'stable'
  ): Promise<{ assignments: ScheduleAssignment[]; metadata: ScheduleResponse['metadata'] }> {
    return generateScheduleWithOrTools(classes, instructorAvailability, constraints, version);
  }

  async compareSchedules(
    classes: Class[],
    instructorAvailability: InstructorAvailability[],
    constraints: ScheduleConstraints
  ): Promise<ComparisonResult> {
    return compareScheduleSolvers(classes, instructorAvailability, constraints);
  }

  async updateSolverConfig(weights: WeightConfig): Promise<{ current_weights: WeightConfig }> {
    const response = await fetch(`${this.baseUrl}/solver/config`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ weights }),
    });

    if (!response.ok) {
      const data = await response.json();
      throw new Error(data.detail || data.message || 'Failed to update solver configuration');
    }
    
    const result = await response.json();
    return result;
  }
  async resetSolverConfig(): Promise<{ current_weights: WeightConfig }> {
    const response = await fetch(`${this.baseUrl}/solver/config/reset`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const data = await response.json();
      throw new Error(data.detail || data.message || 'Failed to reset solver configuration');
    }
    
    const result = await response.json();
    return result;
  }
}

export const apiClient = new ApiClient();

interface ScheduleRequest {
  classes: Class[];
  instructorAvailability: InstructorAvailability[];
  startDate: string;
  endDate: string;
  constraints: {
    maxClassesPerDay: number;
    maxClassesPerWeek: number;
    minPeriodsPerWeek: number;
    maxConsecutiveClasses: 1 | 2;
    consecutiveClassesRule: 'hard' | 'soft';
    startDate: string;  // Added to match backend expectations
    endDate: string;    // Added to match backend expectations
  };
}

interface ScheduleResponse {
  assignments: ScheduleAssignment[];
  metadata: ScheduleMetadata;
}

interface ValidationError {
  detail: string;
  errors: Array<{
    location: string;
    message: string;
    type: string;
  }>;
}

const SCHEDULER_URL = import.meta.env.PROD 
  ? '/api'  // Production URL
  : 'http://localhost:8000';  // FastAPI development URL

type SchedulerVersion = 'stable' | 'dev';

export async function generateScheduleWithOrTools(
  classes: Class[],
  instructorAvailability: InstructorAvailability[],
  constraints: ScheduleConstraints,
  version: SchedulerVersion = 'stable'
): Promise<{ assignments: ScheduleAssignment[]; metadata: ScheduleResponse['metadata'] }> {
  const request: ScheduleRequest = {
    classes,
    instructorAvailability,
    startDate: constraints.startDate,
    endDate: constraints.endDate,
    constraints: {
      maxClassesPerDay: constraints.maxClassesPerDay,
      maxClassesPerWeek: constraints.maxClassesPerWeek,
      minPeriodsPerWeek: constraints.minPeriodsPerWeek,
      maxConsecutiveClasses: constraints.maxConsecutiveClasses,
      consecutiveClassesRule: constraints.consecutiveClassesRule,
      startDate: constraints.startDate,
      endDate: constraints.endDate
    },
  };

  try {
    // Use explicit endpoint paths instead of query parameters
    const url = `${SCHEDULER_URL}/schedule/${version}`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    const data = await response.json();

    if (!response.ok) {
      // Handle validation errors
      if (response.status === 422) {
        const validationError = data;
        if (Array.isArray(validationError)) {
          const errorMessage = validationError
            .map(err => err.msg || err.message || JSON.stringify(err))
            .join('\n');
          throw new Error(`Validation errors:\n${errorMessage}`);
        } else if (validationError.detail) {
          throw new Error(validationError.detail);
        }
      }
      throw new Error(data.detail || data.message || 'Failed to generate schedule');
    }

    // Ensure we have a valid response structure
    if (!data.assignments || !data.metadata) {
      throw new Error('Invalid response format from server');
    }

    return {
      assignments: data.assignments,
      metadata: data.metadata,
    };
  } catch (error) {
    console.error('Schedule generation error:', error);
    throw error;
  }
}

export async function compareScheduleSolvers(
  classes: Class[],
  instructorAvailability: InstructorAvailability[],
  constraints: ScheduleConstraints
): Promise<ComparisonResult> {
  const request: ScheduleRequest = {
    classes,
    instructorAvailability,
    startDate: constraints.startDate,
    endDate: constraints.endDate,
    constraints: {
      maxClassesPerDay: constraints.maxClassesPerDay,
      maxClassesPerWeek: constraints.maxClassesPerWeek,
      minPeriodsPerWeek: constraints.minPeriodsPerWeek,
      maxConsecutiveClasses: constraints.maxConsecutiveClasses,
      consecutiveClassesRule: constraints.consecutiveClassesRule,
      startDate: constraints.startDate,
      endDate: constraints.endDate
    },
  };

  try {
    const url = `${SCHEDULER_URL}/schedule/compare`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    const data = await response.json();

    if (!response.ok) {
      if (response.status === 422 && 'errors' in data) {
        const validationError = data as ValidationError;
        const errorMessage = validationError.errors
          .map(err => `${err.location}: ${err.message}`)
          .join('\n');
        throw new Error(`Validation error:\n${errorMessage}`);
      }
      throw new Error(data.detail || data.message || 'Failed to compare schedules');
    }
    
    // Transform API response to match ComparisonResult type
    return {
      stable: data.stable,
      dev: data.dev,
      differences: data.comparison.assignment_differences,
      metrics: data.comparison.metric_differences
    };
  } catch (error) {
    console.error('Schedule comparison error:', error);
    throw error;
  }
}

================
File: src/lib/csvParser.ts
================
import { Class, WeeklySchedule, TimeSlot } from '../types';

const parsePeriodsString = (periodsStr: string): number[] => {
  // Remove any quotes and extra whitespace
  const cleaned = periodsStr.replace(/['"]/g, '').trim();
  
  // If empty, return empty array
  if (!cleaned) return [];
  
  // Split by comma and convert to numbers, handling whitespace
  return cleaned.split(',').map(p => parseInt(p.trim(), 10))
    .filter(n => !isNaN(n)); // Filter out any invalid numbers
};

export const parseClassesCSV = (csvContent: string): Class[] => {
  const lines = csvContent.trim().split('\n');
  
  // Skip header row
  return lines.slice(1).map(line => {
    // Split the line by commas, but handle quoted values
    const fields: string[] = [];
    let field = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        fields.push(field.trim());
        field = '';
      } else {
        field += char;
      }
    }
    fields.push(field.trim()); // Add the last field
    
    // Extract grade from class name
    const className = fields[0];
    let grade: string;
    
    if (className.startsWith('PK')) {
      grade = 'Pre-K';
    } else if (className.startsWith('K')) {
      grade = className.includes(',') ? 'multiple' : 'K';
    } else if (className.includes(',')) {
      grade = 'multiple';
    } else {
      grade = className.split('-')[0];
    }
    
    // Parse conflicts for each day
    const conflicts: TimeSlot[] = [];
    
    // Process each day's conflicts (fields 1-5 are Mon-Fri)
    for (let dayIndex = 0; dayIndex < 5; dayIndex++) {
      const periodsStr = fields[dayIndex + 1]; // +1 because first field is class name
      if (periodsStr) {
        const periods = parsePeriodsString(periodsStr);
        periods.forEach(period => {
          if (!isNaN(period)) {
            conflicts.push({
              dayOfWeek: dayIndex + 1, // 1-5 for Monday-Friday
              period
            });
          }
        });
      }
    }
    
    // Create the weekly schedule
    const weeklySchedule: WeeklySchedule = {
      conflicts,
      preferredPeriods: [], // Initialize empty
      requiredPeriods: [],  // Initialize empty
      avoidPeriods: []      // Initialize empty
    };
    
    return {
      id: className,
      name: className,
      grade,
      weeklySchedule
    };
  });
};

================
File: src/lib/scheduleComplexity.ts
================
import type { Class, TeacherAvailability, ScheduleConstraints } from '../types';

export interface ComplexityMetrics {
  totalClasses: number;
  totalDays: number;
  constraintComplexity: number;
  teacherConflicts: number;
  overallComplexity: number;
}

export interface SolverDecision {
  solverVersion: 'stable' | 'dev';
  reason: string;
  metrics: ComplexityMetrics;
}

/**
 * Analyzes schedule complexity to determine which solver version to use
 */
export function analyzeScheduleComplexity(
  classes: Class[],
  teacherAvailability: TeacherAvailability[],
  constraints: ScheduleConstraints
): SolverDecision {
  // Calculate basic metrics
  const totalClasses = classes.length;
  const startDate = new Date(constraints.startDate);
  const endDate = new Date(constraints.endDate);
  const totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));

  // Calculate constraint complexity
  const constraintComplexity = calculateConstraintComplexity(classes, constraints);
  
  // Calculate teacher conflict complexity
  const teacherConflicts = calculateTeacherConflicts(teacherAvailability);

  // Calculate overall complexity score (0-100)
  const overallComplexity = calculateOverallComplexity({
    totalClasses,
    totalDays,
    constraintComplexity,
    teacherConflicts,
    overallComplexity: 0 // placeholder, will be calculated
  });

  const metrics: ComplexityMetrics = {
    totalClasses,
    totalDays,
    constraintComplexity,
    teacherConflicts,
    overallComplexity
  };

  // Decision thresholds for using dev solver
  const useDev = 
    totalClasses > 20 ||                  // Many classes
    constraintComplexity > 80 ||          // Very complex constraints
    teacherConflicts > 30 ||              // Many teacher conflicts
    overallComplexity > 70;               // High overall complexity

  if (useDev) {
    return {
      solverVersion: 'dev',
      reason: determineSolverReason(metrics, 'dev'),
      metrics
    };
  }

  return {
    solverVersion: 'stable',
    reason: determineSolverReason(metrics, 'stable'),
    metrics
  };
}

function calculateConstraintComplexity(
  classes: Class[],
  constraints: ScheduleConstraints
): number {
  let complexity = 0;

  // Base complexity from global constraints
  complexity += constraints.maxConsecutiveClasses === 1 ? 10 : 20;
  complexity += constraints.consecutiveClassesRule === 'hard' ? 15 : 5;
  
  // Class-specific constraints
  for (const classObj of classes) {
    // Required periods add significant complexity
    complexity += classObj.weeklySchedule.requiredPeriods.length * 5;
    
    // Conflicts add moderate complexity
    complexity += classObj.weeklySchedule.conflicts.length * 3;
    
    // Preferences add slight complexity
    complexity += classObj.weeklySchedule.preferredPeriods.length;
    complexity += classObj.weeklySchedule.avoidPeriods.length;
  }

  // Normalize to 0-100 scale
  return Math.min(100, complexity);
}

function calculateTeacherConflicts(teacherAvailability: TeacherAvailability[]): number {
  return teacherAvailability.reduce(
    (total, ta) => total + ta.unavailableSlots.length,
    0
  );
}

function calculateOverallComplexity(metrics: ComplexityMetrics): number {
  const weights = {
    classes: 0.3,
    days: 0.1,
    constraints: 0.4,
    conflicts: 0.2
  };

  // Normalize each component to 0-100 scale
  const normalizedClasses = Math.min(100, (metrics.totalClasses / 20) * 100);
  const normalizedDays = Math.min(100, (metrics.totalDays / 30) * 100);

  return Math.min(100,
    normalizedClasses * weights.classes +
    normalizedDays * weights.days +
    metrics.constraintComplexity * weights.constraints +
    Math.min(100, (metrics.teacherConflicts / 30) * 100) * weights.conflicts
  );
}

function determineSolverReason(metrics: ComplexityMetrics, version: 'stable' | 'dev'): string {
  const reasons: string[] = [];

  if (version === 'dev') {
    if (metrics.totalClasses > 20) {
      reasons.push('large number of classes');
    }
    if (metrics.constraintComplexity > 80) {
      reasons.push('very complex scheduling constraints');
    }
    if (metrics.teacherConflicts > 30) {
      reasons.push('high number of teacher conflicts');
    }
    if (metrics.overallComplexity > 70) {
      reasons.push('high overall scheduling complexity');
    }
    return `Using development solver for ${reasons.join(' and ')}`;
  } else {
    return 'Using stable solver for standard scheduling complexity';
  }
}

================
File: src/lib/scheduler.ts
================
import { Class, ScheduleAssignment, TeacherAvailability } from '../types';
import { generateScheduleWithOrTools } from './apiClient';

interface SchedulerParams {
  classes: Class[];
  teacherAvailability: TeacherAvailability[];
  startDate: Date;
  endDate: Date;
  maxClassesPerDay: number;
  maxClassesPerWeek: number;
  minPeriodsPerWeek: number;
  maxConsecutiveClasses: 1 | 2;
  consecutiveClassesRule: 'hard' | 'soft';
}

/**
 * Frontend scheduler interface that uses the OR-Tools CP-SAT solver backend
 */
class Scheduler {
  private classes: Class[];
  private teacherAvailability: TeacherAvailability[];
  private startDate: Date;
  private endDate: Date;
  private maxClassesPerDay: number;
  private maxClassesPerWeek: number;
  private minPeriodsPerWeek: number;
  private maxConsecutiveClasses: 1 | 2;
  private consecutiveClassesRule: 'hard' | 'soft';
  
  constructor(params: SchedulerParams) {
    this.classes = params.classes;
    this.teacherAvailability = params.teacherAvailability;
    this.startDate = params.startDate;
    this.endDate = params.endDate;
    this.maxClassesPerDay = params.maxClassesPerDay;
    this.maxClassesPerWeek = params.maxClassesPerWeek;
    this.minPeriodsPerWeek = params.minPeriodsPerWeek;
    this.maxConsecutiveClasses = params.maxConsecutiveClasses;
    this.consecutiveClassesRule = params.consecutiveClassesRule;
  }

  async solve(version: 'stable' | 'dev' = 'stable'): Promise<ScheduleAssignment[]> {
    const response = await generateScheduleWithOrTools(
      this.classes,
      this.teacherAvailability,
      {
        startDate: this.startDate.toISOString(),
        endDate: this.endDate.toISOString(),
        maxClassesPerDay: this.maxClassesPerDay,
        maxClassesPerWeek: this.maxClassesPerWeek,
        minPeriodsPerWeek: this.minPeriodsPerWeek,
        maxConsecutiveClasses: this.maxConsecutiveClasses,
        consecutiveClassesRule: this.consecutiveClassesRule
      },
      version
    );

    return response.assignments;
  }
}

export default Scheduler;

================
File: src/lib/schedulerWorker.ts
================
// Web Worker for handling scheduling computation
import Scheduler from './scheduler';
import type { Class, TeacherAvailability, ScheduleAssignment } from '../types';

interface ScheduleRequest {
  classes: Class[];
  teacherAvailability: TeacherAvailability[];
  startDate: string;
  endDate: string;
  maxClassesPerDay: number;
  maxClassesPerWeek: number;
  minPeriodsPerWeek: number;
  maxConsecutiveClasses: 1 | 2;
  consecutiveClassesRule: 'hard' | 'soft';
  version?: 'stable' | 'dev';
}

self.onmessage = async (e: MessageEvent<ScheduleRequest>) => {
  try {
    const scheduler = new Scheduler({
      ...e.data,
      startDate: new Date(e.data.startDate),
      endDate: new Date(e.data.endDate)
    });

    // Progress updates are now handled by the backend
    const assignments = await scheduler.solve(e.data.version);
    self.postMessage({ type: 'success', assignments });
  } catch (error) {
    self.postMessage({ 
      type: 'error', 
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
};

================
File: src/store/scheduleStore.ts
================
import { create } from 'zustand';
import { addDays } from 'date-fns';
import type { 
  Class, 
  ScheduleAssignment, 
  ScheduleConstraints, 
  InstructorAvailability,
  ScheduleMetadata 
} from '../types';
import type { ComparisonResult } from './types';
import { analyzeScheduleComplexity, type SolverDecision } from '../lib/scheduleComplexity';
import { generateScheduleWithOrTools, compareScheduleSolvers } from '../lib/apiClient';

interface ScheduleState {
  classes: Class[];
  instructorAvailability: InstructorAvailability[];
  assignments: ScheduleAssignment[];
  constraints: ScheduleConstraints;
  isGenerating: boolean;
  generationProgress: number;
  solverDecision: SolverDecision | null;
  schedulerVersion: 'stable' | 'dev';
  lastGenerationMetadata: ScheduleMetadata | null;
  comparisonResult: ComparisonResult | null;
  isComparing: boolean;
  error: string | null;
  setClasses: (classes: Class[]) => void;
  setInstructorAvailability: (availability: InstructorAvailability[] | ((prev: InstructorAvailability[]) => InstructorAvailability[])) => void;
  setConstraints: (constraints: Partial<ScheduleConstraints>) => void;
  setSchedulerVersion: (version: 'stable' | 'dev') => void;
  generateSchedule: () => Promise<void>;
  compareVersions: () => Promise<void>;
  cancelGeneration: () => void;
  clearError: () => void;
}

const defaultConstraints: ScheduleConstraints = {
  maxClassesPerDay: 4,
  maxClassesPerWeek: 16,
  minPeriodsPerWeek: 8,
  maxConsecutiveClasses: 1,
  consecutiveClassesRule: 'soft',
  startDate: new Date().toISOString(),
  endDate: addDays(new Date(), 30).toISOString()
};

export const useScheduleStore = create<ScheduleState>((set, get) => {
  let worker: Worker | null = null;

  return {
    classes: [],
    instructorAvailability: [],
    assignments: [],
    constraints: defaultConstraints,
    isGenerating: false,
    generationProgress: 0,
    solverDecision: null,
    schedulerVersion: 'stable',
    lastGenerationMetadata: null,
    comparisonResult: null,
    isComparing: false,
    error: null,
    
    setClasses: (classes: Class[]) => set({ classes }),
    
    setInstructorAvailability: (availability: InstructorAvailability[] | ((prev: InstructorAvailability[]) => InstructorAvailability[])) => 
      set((state) => ({ 
        instructorAvailability: typeof availability === 'function' 
          ? availability(state.instructorAvailability)
          : availability 
      })),
    
    setConstraints: (newConstraints: Partial<ScheduleConstraints>) => 
      set((state) => ({
        constraints: { ...state.constraints, ...newConstraints }
      })),

    setSchedulerVersion: (version: 'stable' | 'dev') => set({ schedulerVersion: version }),
    
    generateSchedule: async () => {
      const { classes, instructorAvailability, constraints, schedulerVersion } = get();
      
      if (classes.length === 0) {
        set({ error: 'No classes to schedule. Please add classes first.' });
        return;
      }

      if (constraints.minPeriodsPerWeek > constraints.maxClassesPerWeek) {
        set({ error: 'Minimum periods per week cannot be greater than maximum classes per week.' });
        return;
      }

      // Clear any previous errors
      set({ error: null });

      // Analyze schedule complexity and choose solver
      const decision = analyzeScheduleComplexity(classes, instructorAvailability, constraints);
      set({ solverDecision: decision });

      set({ isGenerating: true, generationProgress: 0 });

      try {
        // Use Python backend solver via API
        const result = await generateScheduleWithOrTools(
          classes,
          instructorAvailability,
          constraints,
          schedulerVersion
        );

        set({
          assignments: result.assignments,
          lastGenerationMetadata: result.metadata,
          isGenerating: false,
          generationProgress: 100,
          error: null
        });
      } catch (error) {
        set({ 
          isGenerating: false, 
          generationProgress: 0,
          error: error instanceof Error ? error.message : 'Failed to generate schedule'
        });
        throw error;
      }
    },

    compareVersions: async () => {
      const { classes, instructorAvailability, constraints } = get();
      
      if (classes.length === 0) {
        set({ error: 'No classes to schedule. Please add classes first.' });
        return;
      }

      // Clear any previous errors
      set({ error: null, isComparing: true });

      try {
        const result = await compareScheduleSolvers(
          classes,
          instructorAvailability,
          constraints
        );

        set({
          comparisonResult: result,
          isComparing: false,
          error: null
        });
      } catch (error) {
        set({ 
          isComparing: false,
          error: error instanceof Error ? error.message : 'Failed to compare solvers'
        });
        throw error;
      }
    },

    cancelGeneration: () => {
      if (worker) {
        worker.terminate();
        worker = null;
        set({ isGenerating: false, generationProgress: 0 });
      }
    },

    clearError: () => set({ error: null })
  };
});

================
File: src/store/testData.ts
================
import { Class, InstructorAvailability, ScheduleMetadata } from '../types';
import { addDays, format } from 'date-fns';

// Helper to create dates for availability
const createDateStr = (daysToAdd: number) => 
  format(addDays(new Date(), daysToAdd), 'yyyy-MM-dd');

// Test Classes
export const testClasses: Class[] = [
  {
    name: '1-101',
    grade: '1',
    conflicts: [
      { dayOfWeek: 1, period: 1 },  // Monday first period
      { dayOfWeek: 3, period: 4 },  // Wednesday fourth period
    ],
    required_periods: []  // No required periods - basic case
  },
  {
    name: '2-205',
    grade: '2',
    conflicts: [
      { dayOfWeek: 2, period: 5 },  // Tuesday fifth period (lunch)
      { dayOfWeek: 4, period: 5 },  // Thursday fifth period
    ],
    required_periods: [
      { date: createDateStr(4), period: 2 }  // Must be Friday second period
    ]
  },
  {
    name: '3-301',
    grade: '3',
    conflicts: [
      { dayOfWeek: 1, period: 6 },  // Monday sixth period
      { dayOfWeek: 3, period: 6 },  // Wednesday sixth period
      { dayOfWeek: 5, period: 6 },  // Friday sixth period
    ],
    required_periods: [
      { date: createDateStr(0), period: 4 }  // Must be Monday fourth period
    ]
  },
  {
    name: 'K-102',
    grade: 'K',
    conflicts: [
      { dayOfWeek: 2, period: 3 },  // Tuesday third period
      { dayOfWeek: 4, period: 3 },  // Thursday third period
    ],
    required_periods: [
      { date: createDateStr(4), period: 2 }  // Must be Friday second period
    ]
  },
  {
    name: 'PK-A',
    grade: 'Pre-K',
    conflicts: [
      { dayOfWeek: 1, period: 8 },  // Monday eighth period
      { dayOfWeek: 2, period: 8 },  // Tuesday eighth period
      { dayOfWeek: 3, period: 8 },  // Wednesday eighth period
      { dayOfWeek: 4, period: 8 },  // Thursday eighth period
      { dayOfWeek: 5, period: 8 },  // Friday eighth period
    ],
    required_periods: []  // No required periods - basic case
  }
];

// Test Schedule Metadata with Distribution Metrics
export const testScheduleMetadata: ScheduleMetadata = {
  duration_ms: 1250,  // 1.25 seconds
  solutions_found: 5,
  score: 15750,
  gap: 0.15,
  distribution: {
    weekly: {
      variance: 0.75,
      classesPerWeek: {
        "1": 12,
        "2": 13,
        "3": 11,
        "4": 14
      },
      score: -75  // -100 * variance
    },
    daily: {
      "2025-02-10": {  // Week 1 Monday
        periodSpread: 0.85,
        classLoadVariance: 0.5,
        classesByPeriod: {
          "1": 1,
          "2": 1,
          "3": 2,
          "4": 1,
          "5": 0,
          "6": 1,
          "7": 0,
          "8": 0
        }
      },
      "2025-02-11": {  // Week 1 Tuesday
        periodSpread: 0.92,
        classLoadVariance: 0.3,
        classesByPeriod: {
          "1": 1,
          "2": 1,
          "3": 1,
          "4": 1,
          "5": 1,
          "6": 1,
          "7": 0,
          "8": 0
        }
      },
      "2025-02-12": {  // Week 1 Wednesday
        periodSpread: 0.78,
        classLoadVariance: 0.8,
        classesByPeriod: {
          "1": 2,
          "2": 0,
          "3": 1,
          "4": 1,
          "5": 0,
          "6": 1,
          "7": 1,
          "8": 0
        }
      }
    },
    totalScore: -500  // weekly.score + daily.score
  }
};

// Test Instructor Availability
export const testInstructorAvailability: InstructorAvailability[] = [
  {
    date: createDateStr(0),
    periods: [4, 5]  // Meeting during period 4, Lunch during period 5
  },
  {
    date: createDateStr(1),
    periods: [5]  // Lunch during period 5
  },
  {
    date: createDateStr(2),
    periods: [5]  // Lunch during period 5
  },
  {
    date: createDateStr(4),
    periods: [2]  // Meeting during period 2
  }
];

================
File: src/store/types.ts
================
import type { ScheduleAssignment, ScheduleMetadata } from '../types';

export interface ComparisonResult {
  stable: {
    assignments: ScheduleAssignment[];
    metadata: ScheduleMetadata;
  };
  dev: {
    assignments: ScheduleAssignment[];
    metadata: ScheduleMetadata;
  };
  differences: {
    total_differences: number;
    differences: Array<{
      type: 'missing_in_stable' | 'missing_in_dev' | 'different_assignment';
      classId: string;
      stable?: ScheduleAssignment;
      dev?: ScheduleAssignment;
    }>;
  };
  metrics: {
    score: number;
    duration: number;
    distribution: {
      score_difference: number;
      weekly_variance_difference: number;
      average_period_spread_difference: number;
    };
  };
}

export interface ScheduleComparisonProps {
  result: ComparisonResult | null;
  isComparing: boolean;
  onCompare: () => void;
}

================
File: src/types/index.ts
================
export interface TimeSlot {
  dayOfWeek: number;  // 1-5 for Monday-Friday
  period: number;     // 1-8
}

export interface RequiredPeriod {
  date: string;
  period: number;
}

export interface ConflictPeriod {
  dayOfWeek: number;
  period: number;
}

export interface Class {
  name: string;
  grade: string;
  conflicts: ConflictPeriod[];
  required_periods: RequiredPeriod[];
}

export interface InstructorAvailability {
  date: string;
  periods: number[];  // List of periods when instructor is unavailable
}

export interface ScheduleConstraints {
  maxClassesPerDay: number;
  maxClassesPerWeek: number;
  minPeriodsPerWeek: number;
  maxConsecutiveClasses: 1 | 2;
  consecutiveClassesRule: 'hard' | 'soft';
  startDate: string;
  endDate: string;
}

export interface ScheduleAssignment {
  name: string;  // Class name (e.g., PK207)
  date: string;
  timeSlot: TimeSlot;
}

export interface ScheduleMetadata {
  duration_ms: number;
  solutions_found: number;
  score: number;
  gap: number;
  distribution?: DistributionMetrics;
}

export interface WeeklyDistributionMetrics {
  variance: number;
  classesPerWeek: Record<string, number>;
  score: number;
}

export interface DailyDistributionMetrics {
  periodSpread: number;
  classLoadVariance: number;  // renamed from teacherLoadVariance
  classesByPeriod: Record<string, number>;
}

export interface DistributionMetrics {
  weekly: WeeklyDistributionMetrics;
  daily: Record<string, DailyDistributionMetrics>;
  totalScore: number;
}

export interface SolverWeights {
  final_week_compression: number;
  day_usage: number;
  daily_balance: number;
  preferred_periods: number;
  distribution: number;
  avoid_periods: number;
  earlier_dates: number;
}

================
File: src/App.tsx
================
import React from 'react';
import { Calendar } from './components/Calendar';
import { FileUpload } from './components/FileUpload';
import { InstructorAvailability } from './components/InstructorAvailability';
import { ConstraintsForm } from './components/ConstraintsForm';
import { ClassEditor } from './components/ClassEditor';
import { ScheduleDebugPanel } from './components/ScheduleDebugPanel';
import { SolverConfig } from './components/SolverConfig';
import { useScheduleStore } from './store/scheduleStore';
import { Calendar as CalendarIcon, AlertCircle, Play, Settings } from 'lucide-react';
import { testClasses, testInstructorAvailability } from './store/testData';

function App() {
  const { classes, generateSchedule, setClasses, setInstructorAvailability } = useScheduleStore();
  const [error, setError] = React.useState<string | null>(null);
  const [showConfig, setShowConfig] = React.useState(false);

  const handleGenerateSchedule = () => {
    try {
      setError(null);
      generateSchedule();
    } catch (err) {
      setError((err as Error).message);
    }
  };

  const loadTestData = () => {
    setClasses(testClasses);
    setInstructorAvailability(testInstructorAvailability);
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8 flex items-center justify-between">
          <div className="flex items-center gap-2">
            <CalendarIcon className="text-blue-500" />
            <h1 className="text-3xl font-bold text-gray-900">Gym Class Rotation Scheduler</h1>
          </div>
          <div className="flex items-center gap-2">
            <button
              onClick={loadTestData}
              className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600"
            >
              <Play size={20} />
              Load Test Data
            </button>
            <button
              onClick={() => setShowConfig(!showConfig)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600"
            >
              <Settings size={20} />
              {showConfig ? 'Hide Config' : 'Show Config'}
            </button>
          </div>
        </div>
      </header>

      <main className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        <div className="space-y-6">
          <div className="bg-white shadow rounded-lg p-6">
            <FileUpload />
          </div>

          <ClassEditor />

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <InstructorAvailability />
            <ConstraintsForm />
          </div>

          {showConfig && (
            <div className="bg-white shadow rounded-lg">
              <SolverConfig />
            </div>
          )}

          {error && (
            <div className="bg-red-50 border-l-4 border-red-400 p-4">
              <div className="flex items-center">
                <AlertCircle className="text-red-400" />
                <p className="ml-3 text-red-700">{error}</p>
              </div>
            </div>
          )}

          <div className="flex justify-center">
            <button
              onClick={handleGenerateSchedule}
              disabled={classes.length === 0}
              className="px-6 py-3 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Generate Rotation Schedule
            </button>
          </div>

          <Calendar />
        </div>
      </main>

      <ScheduleDebugPanel />
    </div>
  );
}

export default App;

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

================
File: src/main.tsx
================
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: .clinerules
================
# Cline Rules: Gym Class Rotation Scheduler

## Project Patterns

### Code Organization
- React components in src/components/
- Core business logic in src/lib/
- State management in src/store/
- TypeScript types in src/types/
- Memory Bank documentation in memory-bank/

### Naming Conventions
- React components: PascalCase
- TypeScript interfaces: PascalCase
- Functions/variables: camelCase
- Files: camelCase.ts(x)
- Constants: UPPER_SNAKE_CASE

### Component Structure
- Functional components with hooks
- Props interface defined above component
- Local state at top of component
- Effects after state
- Helper functions before return
- JSX with Tailwind classes

### State Management
- Use Zustand for global state
- Component state for UI-only concerns
- Immutable state updates
- TypeScript for type safety

### Algorithm Patterns
- Backtracking with constraint satisfaction
- Cache optimization for performance
- Progress tracking for long operations
- Comprehensive validation

### Error Handling
- Clear error messages
- User-friendly display
- Debug panel information
- Validation at multiple levels

### File Operations
- CSV import support
- JSON data structures
- Local state persistence
- Type-safe data handling

## Development Workflow
1. Read Memory Bank for context
2. Make focused, atomic changes
3. Update documentation
4. Test functionality
5. Commit changes

## Key Insights
- Complex scheduling requires careful constraint management
- Performance optimization is critical for large datasets
- Clear error messages help users resolve issues
- Debug panel aids development and troubleshooting
- Test data helps verify functionality

## Project Intelligence
- Scheduling algorithm is sensitive to constraint order
- UI components follow a consistent pattern
- State updates must maintain type safety
- File operations need error handling
- Performance depends on caching strategy

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: eslint.config.js
================
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  }
);

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "scheduler-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "date-fns": "^2.30.0",
    "lucide-react": "^0.263.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zustand": "^4.4.1"
  },
  "devDependencies": {
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "@vitejs/plugin-react": "^4.0.3",
    "autoprefixer": "^10.4.15",
    "eslint": "^8.45.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.3",
    "postcss": "^8.4.29",
    "tailwindcss": "^3.3.3",
    "typescript": "^5.0.2",
    "vite": "^4.4.5"
  }
}

================
File: postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
};

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  optimizeDeps: {
    exclude: ['lucide-react'],
  },
});



================================================================
End of Codebase
================================================================
